/*
 * Automatically generated, do not edit this file directly
 */


#include <config.h>

#include "animation.h"
#include "application.h"
#include "bitmapimage.h"
#include "bitmapsource.h"
#include "border.h"
#include "brush.h"
#include "canvas.h"
#include "collection.h"
#include "color.h"
#include "contentcontrol.h"
#include "control.h"
#include "deepzoomimagetilesource.h"
#include "dependencyobject.h"
#include "dependencyproperty.h"
#include "deployment.h"
#include "downloader.h"
#include "easing.h"
#include "frameworkelement.h"
#include "geometry.h"
#include "glyphs.h"
#include "grid.h"
#include "media.h"
#include "mediaelement.h"
#include "multiscaleimage.h"
#include "multiscalesubimage.h"
#include "namescope.h"
#include "panel.h"
#include "plugin-accessibility.h"
#include "popup.h"
#include "provider.h"
#include "shape.h"
#include "style.h"
#include "stylus.h"
#include "template.h"
#include "textblock.h"
#include "textbox.h"
#include "timeline.h"
#include "transform.h"
#include "trigger.h"
#include "uielement.h"
#include "usercontrol.h"
#include "validators.h"

void
Types::RegisterNativeProperties ()
{
	DependencyProperty::Register (this, Type::VISUALBRUSH, "Visual", false, Type::UIELEMENT);
	DependencyProperty::Register (this, Type::VIDEOBRUSH, "SourceName", false, new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::IMAGEBRUSH, "ImageSource", false, Type::IMAGESOURCE);
	DependencyProperty::Register (this, Type::IMAGEBRUSH, "DownloadProgress", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "RadiusY", false, new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "RadiusX", false, new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "GradientOrigin", false, new Value (Point (0.5, 0.5)), Type::POINT);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "Center", false, new Value (Point (0.5, 0.5)), Type::POINT);
	DependencyProperty::Register (this, Type::LINEARGRADIENTBRUSH, "StartPoint", false, Type::POINT);
	DependencyProperty::Register (this, Type::LINEARGRADIENTBRUSH, "EndPoint", false, new Value (Point(1,1)), Type::POINT);
	DependencyProperty::Register (this, Type::SOLIDCOLORBRUSH, "Color", false, new Value (Color (0x00000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::TILEBRUSH, "Stretch", false, new Value (StretchFill), Type::INT32);
	DependencyProperty::Register (this, Type::TILEBRUSH, "AlignmentY", false, new Value (AlignmentYCenter), Type::INT32);
	DependencyProperty::Register (this, Type::TILEBRUSH, "AlignmentX", false, new Value (AlignmentXCenter), Type::INT32);
	DependencyProperty::Register (this, Type::GRADIENTBRUSH, "SpreadMethod", false, new Value (GradientSpreadMethodPad), Type::INT32);
	DependencyProperty::Register (this, Type::GRADIENTBRUSH, "MappingMode", false, new Value (BrushMappingModeRelativeToBoundingBox), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::GRADIENTBRUSH, "GradientStops", false, NULL, Type::GRADIENTSTOP_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::GRADIENTBRUSH, "ColorInterpolationMode", false, new Value (ColorInterpolationModeSRgbLinearInterpolation), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::INKPRESENTER, "Strokes", false, NULL, Type::STROKE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::BRUSH, "Transform", false, Value::CreateUnrefPtr (new MatrixTransform ()), Type::TRANSFORM);
	DependencyProperty::Register (this, Type::BRUSH, "RelativeTransform", false, Value::CreateUnrefPtr (new MatrixTransform ()), Type::TRANSFORM);
	DependencyProperty::Register (this, Type::BRUSH, "Opacity", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::BRUSH, "Changed", false, Type::BOOL);
	DependencyProperty::Register (this, Type::RECTANGLE, "RadiusY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RECTANGLE, "RadiusX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::POLYLINE, "Points", false, NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::POLYLINE, "FillRule", false, new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::POLYGON, "Points", false, NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::POLYGON, "FillRule", false, new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::Register (this, Type::PATH, "Data", false, Type::GEOMETRY);
	DependencyProperty::Register (this, Type::LINE, "Y2", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::LINE, "Y1", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::LINE, "X2", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::LINE, "X1", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MULTISCALEIMAGE, "ViewportWidth", false, new Value (1.0), Type::DOUBLE, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MULTISCALEIMAGE, "ViewportOrigin", false, new Value (Point(0,0)), Type::POINT, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "UseSprings", false, new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "TileFade", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MULTISCALEIMAGE, "SubImages", false, NULL, Type::MULTISCALESUBIMAGE_COLLECTION, false, true, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "Source", false, Type::MULTISCALETILESOURCE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "IsIdle", false, new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "IsDownloading", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "InternalViewportWidth", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "InternalViewportOrigin", false, new Value (Point(0,0)), Type::POINT);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "BlurFactor", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "AspectRatio", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "AllowDownloading", false, new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::IMAGE, "Source", false, NULL, Type::IMAGESOURCE, false, false, false, NULL, NULL, Image::CreateDefaultImageSource, false);
	DependencyProperty::Register (this, Type::USERCONTROL, "Content", false, Type::UIELEMENT);
	DependencyProperty::Register (this, Type::CONTENTCONTROL, "ContentTemplate", false, Type::DATATEMPLATE);
	DependencyProperty::RegisterFull (this, Type::CONTENTCONTROL, "Content", false, NULL, Type::OBJECT, false, false, false, NULL, Validators::ContentControlContentValidator, NULL, false);
	DependencyProperty::Register (this, Type::GRID, "ShowGridLines", false, new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::GRID, "RowSpan", false, new Value (1), Type::INT32, true, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "Row", false, new Value (0), Type::INT32, true, false, false, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "RowDefinitions", false, NULL, Type::ROWDEFINITION_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "ColumnSpan", false, new Value (1), Type::INT32, true, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "Column", false, new Value (0), Type::INT32, true, false, false, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "ColumnDefinitions", false, NULL, Type::COLUMNDEFINITION_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::CANVAS, "ZIndex", false, new Value (0), Type::INT32, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::CANVAS, "Top", false, new Value (0.0), Type::DOUBLE, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::CANVAS, "Left", false, new Value (0.0), Type::DOUBLE, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "TextWrapping", false, new Value (TextWrappingNoWrap), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "Text", false, new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "TextDecorations", false, new Value (TextDecorationsNone), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "TextAlignment", false, new Value (TextAlignmentLeft), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "Padding", false, new Value (Thickness (0)), Type::THICKNESS);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "LineStackingStrategy", false, new Value (LineStackingStrategyMaxHeight), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "LineHeight", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::TEXTBLOCK, "Inlines", false, NULL, Type::INLINE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "Foreground", false, Value::CreateUnrefPtr (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontWeight", false, new Value (FontWeight(TEXTBLOCK_FONT_WEIGHT)), Type::FONTWEIGHT);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontStyle", false, new Value (FontStyle(TEXTBLOCK_FONT_STYLE)), Type::FONTSTYLE);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontStretch", false, new Value (FontStretch(TEXTBLOCK_FONT_STRETCH)), Type::FONTSTRETCH);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontSource", false, Type::FONTSOURCE);
	DependencyProperty::RegisterFull (this, Type::TEXTBLOCK, "FontSize", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, AutoCreators::CreateDefaultFontSize, false);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontFamily", false, new Value (FontFamily(TEXTBLOCK_FONT_FAMILY)), Type::FONTFAMILY);
	DependencyProperty::Register (this, Type::POPUP, "VerticalOffset", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::POPUP, "IsOpen", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::POPUP, "HorizontalOffset", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::POPUP, "Child", false, NULL, Type::UIELEMENT, false, false, false, NULL, Validators::ContentControlContentValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Volume", false, new Value (0.5), Type::DOUBLE, false, false, false, NULL, Validators::VolumeValidator, NULL, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "Stretch", false, new Value (StretchUniform), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Source", false, NULL, Type::URI, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "RenderedFramesPerSecond", false, new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Position", false, NULL, Type::TIMESPAN, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "NaturalVideoWidth", false, new Value (0), Type::INT32, false, true, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "NaturalVideoHeight", false, new Value (0), Type::INT32, false, true, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "NaturalDuration", false, new Value (Duration::FromSeconds (0)), Type::DURATION, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Markers", false, NULL, Type::TIMELINEMARKER_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "IsMuted", false, new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "DroppedFramesPerSecond", false, new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "DownloadProgress", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "DownloadProgressOffset", false, new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "CurrentState", false, new Value (MediaStateClosed), Type::INT32, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "CanSeek", false, new Value (false), Type::BOOL, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "CanPause", false, new Value (false), Type::BOOL, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "BufferingTime", false, NULL, Type::TIMESPAN, false, false, false, NULL, Validators::BufferingTimeValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "BufferingProgress", false, new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Balance", false, new Value (0.0), Type::DOUBLE, false, false, false, NULL, Validators::BalanceValidator, NULL, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "AutoPlay", false, new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "AudioStreamIndex", false, NULL, Type::INT32, false, false, false, NULL, Validators::AudioStreamIndexValidator, NULL, true);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "AudioStreamCount", false, new Value (0), Type::INT32, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Attributes", false, NULL, Type::MEDIAATTRIBUTE_COLLECTION, false, false, false, NULL, Validators::MediaAttributeCollectionValidator, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeThickness", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeStartLineCap", false, new Value (PenLineCapFlat), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "Stroke", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeMiterLimit", false, new Value (10.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeLineJoin", false, new Value (PenLineJoinMiter), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeEndLineCap", false, new Value (PenLineCapFlat), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeDashOffset", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeDashCap", false, new Value (PenLineCapFlat), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeDashArray", false, Type::DOUBLE_COLLECTION);
	DependencyProperty::RegisterFull (this, Type::SHAPE, "Stretch", false, NULL, Type::INT32, false, false, false, NULL, NULL, Shape::CreateDefaultStretch, false);
	DependencyProperty::Register (this, Type::SHAPE, "Fill", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::MEDIABASE, "Stretch", false, new Value (StretchUniform), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::MEDIABASE, "Source", false, NULL, Type::STRING, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::MEDIABASE, "DownloadProgress", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "UnicodeString", false, new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::GLYPHS, "StyleSimulations", false, new Value (StyleSimulationsNone), Type::INT32);
	DependencyProperty::Register (this, Type::GLYPHS, "OriginY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "OriginX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "Indices", false, new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::GLYPHS, "FontUri", false, new Value (Uri()), Type::URI, false, false, false, NULL, Validators::NonNullValidator, NULL, false);
	DependencyProperty::Register (this, Type::GLYPHS, "FontRenderingEmSize", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "Fill", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::CONTROL, "VerticalContentAlignment", false, new Value (VerticalAlignmentCenter), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::CONTROL, "Template", false, NULL, Type::CONTROLTEMPLATE, false, false, false, NULL, Validators::TemplateValidator, NULL, false);
	DependencyProperty::Register (this, Type::CONTROL, "TabNavigation", false, new Value (KeyboardNavigationModeLocal), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "TabIndex", false, new Value (INT_MAX), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "Padding", false, new Value (Thickness(0.0)), Type::THICKNESS);
	DependencyProperty::RegisterFull (this, Type::CONTROL, "IsTemplateItem", false, new Value (false), Type::BOOL, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::CONTROL, "IsTabStop", false, new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::CONTROL, "IsEnabled", false, new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::CONTROL, "HorizontalContentAlignment", false, new Value (HorizontalAlignmentCenter), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "Foreground", false, Value::CreateUnrefPtr (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::CONTROL, "FontWeight", false, new Value (FontWeight(CONTROL_FONT_WEIGHT)), Type::FONTWEIGHT);
	DependencyProperty::Register (this, Type::CONTROL, "FontStyle", false, new Value (FontStyle(CONTROL_FONT_STYLE)), Type::FONTSTYLE);
	DependencyProperty::Register (this, Type::CONTROL, "FontStretch", false, new Value (FontStretch(CONTROL_FONT_STRETCH)), Type::FONTSTRETCH);
	DependencyProperty::RegisterFull (this, Type::CONTROL, "FontSize", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, AutoCreators::CreateDefaultFontSize, false);
	DependencyProperty::Register (this, Type::CONTROL, "FontFamily", false, new Value (FontFamily(CONTROL_FONT_FAMILY)), Type::FONTFAMILY);
	DependencyProperty::Register (this, Type::CONTROL, "DefaultStyleKey", false, Type::MANAGEDTYPEINFO);
	DependencyProperty::Register (this, Type::CONTROL, "BorderThickness", false, new Value (Thickness(0.0)), Type::THICKNESS);
	DependencyProperty::Register (this, Type::CONTROL, "BorderBrush", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::CONTROL, "Background", false, Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::PANEL, "Children", false, NULL, Type::UIELEMENT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::PANEL, "Background", false, Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::BORDER, "Padding", false, new Value (Thickness(0)), Type::THICKNESS, false, false, false, NULL, Validators::BorderThicknessValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::BORDER, "CornerRadius", false, new Value (CornerRadius(0)), Type::CORNERRADIUS, false, false, false, NULL, Validators::CornerRadiusValidator, NULL, false);
	DependencyProperty::Register (this, Type::BORDER, "Child", false, Type::UIELEMENT);
	DependencyProperty::RegisterFull (this, Type::BORDER, "BorderThickness", false, new Value (Thickness(0)), Type::THICKNESS, false, false, false, NULL, Validators::BorderThicknessValidator, NULL, false);
	DependencyProperty::Register (this, Type::BORDER, "BorderBrush", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::BORDER, "Background", false, Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::TIMELINEGROUP, "Children", false, NULL, Type::TIMELINE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::SETTER, "Value", false, NULL, Type::OBJECT, false, false, false, NULL, Validators::IsSetterSealedValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::SETTER, "Property", false, NULL, Type::DEPENDENCYPROPERTY, false, false, false, NULL, Validators::IsSetterSealedValidator, NULL, false);
	DependencyProperty::Register (this, Type::SETTER, "ConvertedValue", false, Type::OBJECT);
	DependencyProperty::Register (this, Type::RUN, "Text", false, Type::STRING);
	DependencyProperty::Register (this, Type::RECTANGLEGEOMETRY, "Rect", false, Type::RECT);
	DependencyProperty::Register (this, Type::RECTANGLEGEOMETRY, "RadiusY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RECTANGLEGEOMETRY, "RadiusX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::PATHGEOMETRY, "FillRule", false, new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::Register (this, Type::PATHGEOMETRY, "Figures", false, Type::PATHFIGURE_COLLECTION);
	DependencyProperty::Register (this, Type::LINEGEOMETRY, "StartPoint", false, Type::POINT);
	DependencyProperty::Register (this, Type::LINEGEOMETRY, "EndPoint", false, Type::POINT);
	DependencyProperty::Register (this, Type::GEOMETRYGROUP, "FillRule", false, new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::GEOMETRYGROUP, "Children", false, NULL, Type::GEOMETRY_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::ELLIPSEGEOMETRY, "RadiusY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELLIPSEGEOMETRY, "RadiusX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELLIPSEGEOMETRY, "Center", false, Type::POINT);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "Width", false, new Value (NAN), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "VerticalAlignment", false, new Value (VerticalAlignmentStretch), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::FRAMEWORKELEMENT, "Style", false, NULL, Type::STYLE, false, false, false, NULL, Validators::StyleValidator, NULL, false);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MinWidth", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MinHeight", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MaxWidth", false, new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MaxHeight", false, new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "Margin", false, new Value (Thickness (0)), Type::THICKNESS);
	DependencyProperty::RegisterFull (this, Type::FRAMEWORKELEMENT, "Language", false, new Value ("en-US"), Type::STRING, false, false, false, NULL, Validators::NonNullValidator, NULL, false);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "HorizontalAlignment", false, new Value (HorizontalAlignmentStretch), Type::INT32);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "Height", false, new Value (NAN), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "DataContext", false, Type::OBJECT);
	DependencyProperty::RegisterFull (this, Type::FRAMEWORKELEMENT, "ActualWidth", false, new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::FRAMEWORKELEMENT, "ActualHeight", false, new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::POWEREASE, "Power", false, new Value (2.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::EXPONENTIALEASE, "Exponent", false, new Value (2.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELASTICEASE, "Springiness", false, new Value (3.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELASTICEASE, "Oscillations", false, new Value (3), Type::INT32);
	DependencyProperty::Register (this, Type::BOUNCEEASE, "Bounciness", false, new Value (2.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::BOUNCEEASE, "Bounces", false, new Value (3), Type::INT32);
	DependencyProperty::Register (this, Type::BACKEASE, "Amplitude", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::SPLINEPOINTKEYFRAME, "KeySpline", false, NULL, Type::KEYSPLINE, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::EASINGPOINTKEYFRAME, "EasingFunction", false, Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::POINTANIMATIONUSINGKEYFRAMES, "KeyFrames", false, NULL, Type::POINTKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::SPLINEDOUBLEKEYFRAME, "KeySpline", false, NULL, Type::KEYSPLINE, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::EASINGDOUBLEKEYFRAME, "EasingFunction", false, Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::DOUBLEANIMATIONUSINGKEYFRAMES, "KeyFrames", false, NULL, Type::DOUBLEKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::TIMELINEMARKER, "Type", false, Type::STRING);
	DependencyProperty::Register (this, Type::TIMELINEMARKER, "Time", false, Type::TIMESPAN);
	DependencyProperty::Register (this, Type::TIMELINEMARKER, "Text", false, Type::STRING);
	DependencyProperty::Register (this, Type::TIMELINE, "SpeedRatio", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::TIMELINE, "RepeatBehavior", false, new Value (RepeatBehavior ((double) 1)), Type::REPEATBEHAVIOR);
	DependencyProperty::Register (this, Type::TIMELINE, "FillBehavior", false, new Value (FillBehaviorHoldEnd), Type::INT32);
	DependencyProperty::Register (this, Type::TIMELINE, "Duration", false, new Value (Duration::Automatic), Type::DURATION);
	DependencyProperty::RegisterFull (this, Type::TIMELINE, "BeginTime", false, new Value ((gint64) 0, Type::TIMESPAN), Type::TIMESPAN, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::Register (this, Type::TIMELINE, "AutoReverse", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::STYLUSPOINT, "Y", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::STYLUSPOINT, "X", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::STYLUSPOINT, "PressureFactor", false, new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::STYLUSINFO, "IsInverted", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::STYLUSINFO, "DeviceType", false, new Value (TabletDeviceTypeMouse), Type::INT32);
	DependencyProperty::Register (this, Type::STYLE, "TargetType", false, Type::MANAGEDTYPEINFO);
	DependencyProperty::RegisterFull (this, Type::STYLE, "Setters", false, NULL, Type::SETTERBASE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::STYLE, "IsSealed", false, new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::STROKE, "StylusPoints", false, NULL, Type::STYLUSPOINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::STROKE, "DrawingAttributes", false, NULL, Type::DRAWINGATTRIBUTES, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::SETTERBASE, "IsSealed", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "MinHeight", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "MaxHeight", false, new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "Height", false, new Value (GridLength (1.0, GridUnitTypeStar)), Type::GRIDLENGTH);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "ActualHeight", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::PATHFIGURE, "StartPoint", false, Type::POINT);
	DependencyProperty::RegisterFull (this, Type::PATHFIGURE, "Segments", false, NULL, Type::PATHSEGMENT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::PATHFIGURE, "IsFilled", false, new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::PATHFIGURE, "IsClosed", false, new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::NAMESCOPE, "NameScope", false, NULL, Type::NAMESCOPE, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "ZIndex", false, new Value (0), Type::INT32);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "ViewportWidth", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "ViewportOrigin", false, new Value (Point(0,0)), Type::POINT);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "Opacity", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MULTISCALESUBIMAGE, "AspectRatio", false, new Value (1.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::MEDIAATTRIBUTE, "Value", false, Type::STRING);
	DependencyProperty::Register (this, Type::MATRIX, "OffsetY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "OffsetX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M22", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M21", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M12", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M11", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::KEYSPLINE, "ControlPoint2", false, new Value (Point (1.0, 1.0)), Type::POINT);
	DependencyProperty::Register (this, Type::KEYSPLINE, "ControlPoint1", false, new Value (Point (0,0)), Type::POINT);
	DependencyProperty::RegisterFull (this, Type::INPUTMETHOD, "IsInputMethodEnabled", false, NULL, Type::BOOL, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::INLINE, "TextDecorations", false, new Value (TextDecorationsNone), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::INLINE, "Language", false, new Value ("en-US"), Type::STRING, false, false, false, NULL, Validators::NonNullValidator, NULL, false);
	DependencyProperty::Register (this, Type::INLINE, "Foreground", false, Value::CreateUnrefPtr (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::INLINE, "FontWeight", false, new Value (FontWeight(TEXTBLOCK_FONT_WEIGHT)), Type::FONTWEIGHT);
	DependencyProperty::Register (this, Type::INLINE, "FontStyle", false, new Value (FontStyle(TEXTBLOCK_FONT_STYLE)), Type::FONTSTYLE);
	DependencyProperty::Register (this, Type::INLINE, "FontStretch", false, new Value (FontStretch(TEXTBLOCK_FONT_STRETCH)), Type::FONTSTRETCH);
	DependencyProperty::Register (this, Type::INLINE, "FontSource", false, Type::FONTSOURCE);
	DependencyProperty::RegisterFull (this, Type::INLINE, "FontSize", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, AutoCreators::CreateDefaultFontSize, false);
	DependencyProperty::Register (this, Type::INLINE, "FontFamily", false, new Value (FontFamily(TEXTBLOCK_FONT_FAMILY)), Type::FONTFAMILY);
	DependencyProperty::Register (this, Type::GRADIENTSTOP, "Offset", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GRADIENTSTOP, "Color", false, new Value (Color (0x00000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::GEOMETRY, "Transform", false, Type::TRANSFORM);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "Width", false, new Value (3.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "OutlineColor", false, new Value (Color (0x00000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "Height", false, new Value (3.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "Color", false, new Value (Color (0xFF000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::DOWNLOADER, "Uri", false, Type::URI);
	DependencyProperty::Register (this, Type::DOWNLOADER, "StatusText", false, new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::DOWNLOADER, "Status", false, new Value (0), Type::INT32);
	DependencyProperty::Register (this, Type::DOWNLOADER, "ResponseText", false, Type::STRING);
	DependencyProperty::Register (this, Type::DOWNLOADER, "DownloadProgress", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "Surface", false, Type::SURFACE);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "RuntimeVersion", false, Type::STRING);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "Parts", false, Type::ASSEMBLYPART_COLLECTION);
	DependencyProperty::RegisterFull (this, Type::DEPLOYMENT, "ExternalCallersFromCrossDomain", false, new Value (CrossDomainAccessNoAccess), Type::INT32, false, false, false, NULL, Validators::CrossDomainValidator, NULL, false);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "EntryPointType", false, Type::STRING);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "EntryPointAssembly", false, Type::STRING);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "Width", false, new Value (GridLength (1.0, GridUnitTypeStar)), Type::GRIDLENGTH);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "MinWidth", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "MaxWidth", false, new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "ActualWidth", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::COLLECTION, "Count", false, new Value (0), Type::INT32);
	DependencyProperty::Register (this, Type::UIELEMENT, "Visibility", false, new Value (VisibilityVisible), Type::INT32);
	DependencyProperty::Register (this, Type::UIELEMENT, "UseLayoutRounding", false, new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::UIELEMENT, "Triggers", false, NULL, Type::TRIGGER_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::UIELEMENT, "Tag", true, Type::OBJECT);
	DependencyProperty::RegisterFull (this, Type::UIELEMENT, "Resources", false, NULL, Type::RESOURCE_DICTIONARY, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::UIELEMENT, "RenderTransform", false, Type::TRANSFORM);
	DependencyProperty::Register (this, Type::UIELEMENT, "RenderTransformOrigin", false, new Value (Point (0,0)), Type::POINT);
	DependencyProperty::Register (this, Type::UIELEMENT, "Opacity", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::UIELEMENT, "OpacityMask", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::UIELEMENT, "IsHitTestVisible", false, new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::UIELEMENT, "Cursor", false, new Value (MouseCursorDefault), Type::INT32, false, false, false, NULL, Validators::CursorValidator, NULL, false);
	DependencyProperty::Register (this, Type::UIELEMENT, "Clip", false, Type::GEOMETRY);
	DependencyProperty::Register (this, Type::EASINGFUNCTIONBASE, "EasingMode", false, new Value (EasingModeOut), Type::INT32);
	DependencyProperty::Register (this, Type::ASSEMBLYPART, "Source", false, new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::APPLICATION, "Resources", false, NULL, Type::RESOURCE_DICTIONARY, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::ACCESSIBILITY, "Title", false, new Value ("Silverlight Content"), Type::STRING);
	DependencyProperty::Register (this, Type::ACCESSIBILITY, "Description", false, new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::ACCESSIBILITY, "ActionDescription", false, new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::SPLINECOLORKEYFRAME, "KeySpline", false, NULL, Type::KEYSPLINE, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::EASINGCOLORKEYFRAME, "EasingFunction", false, Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::COLORANIMATIONUSINGKEYFRAMES, "KeyFrames", false, NULL, Type::COLORKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::BITMAPIMAGE, "UriSource", false, new Value (Uri()), Type::URI, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::BITMAPIMAGE, "Progress", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::TRANSLATETRANSFORM, "Y", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::TRANSLATETRANSFORM, "X", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::TRANSFORMGROUP, "Children", false, NULL, Type::TRANSFORM_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::TEXTBOX, "VerticalScrollBarVisibility", false, new Value (ScrollBarVisibilityHidden), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBOX, "TextWrapping", false, new Value (TextWrappingNoWrap), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBOX, "Text", false, Type::STRING);
	DependencyProperty::Register (this, Type::TEXTBOX, "TextAlignment", false, new Value (TextAlignmentLeft), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "SelectionStart", false, new Value (0), Type::INT32, false, false, true, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "SelectionLength", false, new Value (0), Type::INT32, false, false, true, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::Register (this, Type::TEXTBOX, "SelectionForeground", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::TEXTBOX, "SelectionBackground", false, Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "SelectedText", false, new Value (""), Type::STRING, false, false, true, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "MaxLength", false, new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::Register (this, Type::TEXTBOX, "IsReadOnly", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::TEXTBOX, "HorizontalScrollBarVisibility", false, new Value (ScrollBarVisibilityHidden), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBOX, "FontSource", false, Type::FONTSOURCE);
	DependencyProperty::Register (this, Type::TEXTBOX, "CaretBrush", false, Value::CreateUnrefPtr (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::TEXTBOX, "AcceptsReturn", false, new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::STORYBOARD, "TargetProperty", false, NULL, Type::PROPERTYPATH, true, false, false, NULL, Validators::StoryboardTargetPropertyValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::STORYBOARD, "TargetName", false, NULL, Type::STRING, true, false, false, NULL, Validators::IsTimelineValidator, NULL, false);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "CenterY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "CenterX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "AngleY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "AngleX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SETTERBASE_COLLECTION, "IsSealed", false, new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "ScaleY", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "ScaleX", false, new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "CenterY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "CenterX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROTATETRANSFORM, "CenterY", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROTATETRANSFORM, "CenterX", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROTATETRANSFORM, "Angle", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::QUADRATICBEZIERSEGMENT, "Point2", false, Type::POINT);
	DependencyProperty::Register (this, Type::QUADRATICBEZIERSEGMENT, "Point1", false, Type::POINT);
	DependencyProperty::RegisterFull (this, Type::POLYQUADRATICBEZIERSEGMENT, "Points", false, NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::POLYLINESEGMENT, "Points", false, NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::POLYBEZIERSEGMENT, "Points", false, NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::POINTKEYFRAME, "Value", false, NULL, Type::POINT, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::POINTKEYFRAME, "KeyTime", false, NULL, Type::KEYTIME, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::POINTANIMATION, "To", false, NULL, Type::POINT, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::POINTANIMATION, "From", false, NULL, Type::POINT, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::Register (this, Type::POINTANIMATION, "EasingFunction", false, Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::POINTANIMATION, "By", false, NULL, Type::POINT, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "SelectionStart", false, new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "SelectionLength", false, new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "SelectionForeground", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "SelectionBackground", false, Type::BRUSH);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "SelectedText", false, new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "Password", false, new Value (""), Type::STRING, false, false, true, NULL, Validators::NonNullValidator, NULL, false);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "PasswordChar", false, new Value ((gunichar) 9679, Type::CHAR), Type::CHAR);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "MaxLength", false, new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "FontSource", false, Type::FONTSOURCE);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "CaretBrush", false, Value::CreateUnrefPtr (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::OBJECTKEYFRAME, "Value", false, Type::OBJECT);
	DependencyProperty::RegisterFull (this, Type::OBJECTKEYFRAME, "KeyTime", false, NULL, Type::KEYTIME, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::Register (this, Type::OBJECTKEYFRAME, "ConvertedValue", false, Type::OBJECT);
	DependencyProperty::RegisterFull (this, Type::OBJECTANIMATIONUSINGKEYFRAMES, "KeyFrames", false, NULL, Type::OBJECTKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::Register (this, Type::MATRIXTRANSFORM, "Matrix", false, Type::MATRIX);
	DependencyProperty::Register (this, Type::LINESEGMENT, "Point", false, Type::POINT);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LayoutSlot", false, NULL, Type::RECT, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LayoutClip", false, NULL, Type::GEOMETRY, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LastRenderSize", false, NULL, Type::SIZE, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LastMeasure", false, NULL, Type::SIZE, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LastArrange", false, NULL, Type::SIZE, true, false, false, NULL, NULL, NULL, false);
	DependencyProperty::Register (this, Type::EVENTTRIGGER, "RoutedEvent", false, Type::STRING);
	DependencyProperty::RegisterFull (this, Type::EVENTTRIGGER, "Actions", false, NULL, Type::TRIGGERACTION_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false);
	DependencyProperty::RegisterFull (this, Type::DOUBLEKEYFRAME, "Value", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::DOUBLEKEYFRAME, "KeyTime", false, NULL, Type::KEYTIME, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::DOUBLEANIMATION, "To", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::DOUBLEANIMATION, "From", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::Register (this, Type::DOUBLEANIMATION, "EasingFunction", false, Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::DOUBLEANIMATION, "By", false, NULL, Type::DOUBLE, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::DEPENDENCY_OBJECT, "Name", false, new Value (""), Type::STRING, false, false, false, NULL, Validators::NameValidator, NULL, false);
	DependencyProperty::Register (this, Type::DEEPZOOMIMAGETILESOURCE, "UriSource", false, Type::URI);
	DependencyProperty::Register (this, Type::CONTROLTEMPLATE, "TargetType", false, Type::MANAGEDTYPEINFO);
	DependencyProperty::RegisterFull (this, Type::COLORKEYFRAME, "Value", false, NULL, Type::COLOR, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::COLORKEYFRAME, "KeyTime", false, NULL, Type::KEYTIME, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::COLORANIMATION, "To", false, NULL, Type::COLOR, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::COLORANIMATION, "From", false, NULL, Type::COLOR, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::Register (this, Type::COLORANIMATION, "EasingFunction", false, Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::COLORANIMATION, "By", false, NULL, Type::COLOR, false, false, false, NULL, NULL, NULL, true);
	DependencyProperty::RegisterFull (this, Type::BITMAPSOURCE, "PixelWidth", false, new Value (0), Type::INT32, false, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false);
	DependencyProperty::RegisterFull (this, Type::BITMAPSOURCE, "PixelHeight", false, new Value (0), Type::INT32, false, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false);
	DependencyProperty::Register (this, Type::BITMAPSOURCE, "PixelFormat", false, new Value (PixelFormatPbgra32), Type::INT32);
	DependencyProperty::Register (this, Type::BEZIERSEGMENT, "Point3", false, Type::POINT);
	DependencyProperty::Register (this, Type::BEZIERSEGMENT, "Point2", false, Type::POINT);
	DependencyProperty::Register (this, Type::BEZIERSEGMENT, "Point1", false, Type::POINT);
	DependencyProperty::Register (this, Type::BEGINSTORYBOARD, "Storyboard", false, Type::STORYBOARD);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "SweepDirection", false, new Value (SweepDirectionCounterclockwise), Type::INT32);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "Size", false, Type::SIZE);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "RotationAngle", false, new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "Point", false, Type::POINT);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "IsLargeArc", false, new Value (false), Type::BOOL);
}

const int VisualBrush::VisualProperty = 0;
const int VideoBrush::SourceNameProperty = 1;
const int ImageBrush::ImageSourceProperty = 2;
const int ImageBrush::DownloadProgressProperty = 3;
const int RadialGradientBrush::RadiusYProperty = 4;
const int RadialGradientBrush::RadiusXProperty = 5;
const int RadialGradientBrush::GradientOriginProperty = 6;
const int RadialGradientBrush::CenterProperty = 7;
const int LinearGradientBrush::StartPointProperty = 8;
const int LinearGradientBrush::EndPointProperty = 9;
const int SolidColorBrush::ColorProperty = 10;
const int TileBrush::StretchProperty = 11;
const int TileBrush::AlignmentYProperty = 12;
const int TileBrush::AlignmentXProperty = 13;
const int GradientBrush::SpreadMethodProperty = 14;
const int GradientBrush::MappingModeProperty = 15;
const int GradientBrush::GradientStopsProperty = 16;
const int GradientBrush::ColorInterpolationModeProperty = 17;
const int InkPresenter::StrokesProperty = 18;
const int Brush::TransformProperty = 19;
const int Brush::RelativeTransformProperty = 20;
const int Brush::OpacityProperty = 21;
const int Brush::ChangedProperty = 22;
const int Rectangle::RadiusYProperty = 23;
const int Rectangle::RadiusXProperty = 24;
const int Polyline::PointsProperty = 25;
const int Polyline::FillRuleProperty = 26;
const int Polygon::PointsProperty = 27;
const int Polygon::FillRuleProperty = 28;
const int Path::DataProperty = 29;
const int Line::Y2Property = 30;
const int Line::Y1Property = 31;
const int Line::X2Property = 32;
const int Line::X1Property = 33;
const int MultiScaleImage::ViewportWidthProperty = 34;
const int MultiScaleImage::ViewportOriginProperty = 35;
const int MultiScaleImage::UseSpringsProperty = 36;
const int MultiScaleImage::TileFadeProperty = 37;
const int MultiScaleImage::SubImagesProperty = 38;
const int MultiScaleImage::SourceProperty = 39;
const int MultiScaleImage::IsIdleProperty = 40;
const int MultiScaleImage::IsDownloadingProperty = 41;
const int MultiScaleImage::InternalViewportWidthProperty = 42;
const int MultiScaleImage::InternalViewportOriginProperty = 43;
const int MultiScaleImage::BlurFactorProperty = 44;
const int MultiScaleImage::AspectRatioProperty = 45;
const int MultiScaleImage::AllowDownloadingProperty = 46;
const int Image::SourceProperty = 47;
const int UserControl::ContentProperty = 48;
const int ContentControl::ContentTemplateProperty = 49;
const int ContentControl::ContentProperty = 50;
const int Grid::ShowGridLinesProperty = 51;
const int Grid::RowSpanProperty = 52;
const int Grid::RowProperty = 53;
const int Grid::RowDefinitionsProperty = 54;
const int Grid::ColumnSpanProperty = 55;
const int Grid::ColumnProperty = 56;
const int Grid::ColumnDefinitionsProperty = 57;
const int Canvas::ZIndexProperty = 58;
const int Canvas::TopProperty = 59;
const int Canvas::LeftProperty = 60;
const int TextBlock::TextWrappingProperty = 61;
const int TextBlock::TextProperty = 62;
const int TextBlock::TextDecorationsProperty = 63;
const int TextBlock::TextAlignmentProperty = 64;
const int TextBlock::PaddingProperty = 65;
const int TextBlock::LineStackingStrategyProperty = 66;
const int TextBlock::LineHeightProperty = 67;
const int TextBlock::InlinesProperty = 68;
const int TextBlock::ForegroundProperty = 69;
const int TextBlock::FontWeightProperty = 70;
const int TextBlock::FontStyleProperty = 71;
const int TextBlock::FontStretchProperty = 72;
const int TextBlock::FontSourceProperty = 73;
const int TextBlock::FontSizeProperty = 74;
const int TextBlock::FontFamilyProperty = 75;
const int Popup::VerticalOffsetProperty = 76;
const int Popup::IsOpenProperty = 77;
const int Popup::HorizontalOffsetProperty = 78;
const int Popup::ChildProperty = 79;
const int MediaElement::VolumeProperty = 80;
const int MediaElement::StretchProperty = 81;
const int MediaElement::SourceProperty = 82;
const int MediaElement::RenderedFramesPerSecondProperty = 83;
const int MediaElement::PositionProperty = 84;
const int MediaElement::NaturalVideoWidthProperty = 85;
const int MediaElement::NaturalVideoHeightProperty = 86;
const int MediaElement::NaturalDurationProperty = 87;
const int MediaElement::MarkersProperty = 88;
const int MediaElement::IsMutedProperty = 89;
const int MediaElement::DroppedFramesPerSecondProperty = 90;
const int MediaElement::DownloadProgressProperty = 91;
const int MediaElement::DownloadProgressOffsetProperty = 92;
const int MediaElement::CurrentStateProperty = 93;
const int MediaElement::CanSeekProperty = 94;
const int MediaElement::CanPauseProperty = 95;
const int MediaElement::BufferingTimeProperty = 96;
const int MediaElement::BufferingProgressProperty = 97;
const int MediaElement::BalanceProperty = 98;
const int MediaElement::AutoPlayProperty = 99;
const int MediaElement::AudioStreamIndexProperty = 100;
const int MediaElement::AudioStreamCountProperty = 101;
const int MediaElement::AttributesProperty = 102;
const int Shape::StrokeThicknessProperty = 103;
const int Shape::StrokeStartLineCapProperty = 104;
const int Shape::StrokeProperty = 105;
const int Shape::StrokeMiterLimitProperty = 106;
const int Shape::StrokeLineJoinProperty = 107;
const int Shape::StrokeEndLineCapProperty = 108;
const int Shape::StrokeDashOffsetProperty = 109;
const int Shape::StrokeDashCapProperty = 110;
const int Shape::StrokeDashArrayProperty = 111;
const int Shape::StretchProperty = 112;
const int Shape::FillProperty = 113;
const int MediaBase::StretchProperty = 114;
const int MediaBase::SourceProperty = 115;
const int MediaBase::DownloadProgressProperty = 116;
const int Glyphs::UnicodeStringProperty = 117;
const int Glyphs::StyleSimulationsProperty = 118;
const int Glyphs::OriginYProperty = 119;
const int Glyphs::OriginXProperty = 120;
const int Glyphs::IndicesProperty = 121;
const int Glyphs::FontUriProperty = 122;
const int Glyphs::FontRenderingEmSizeProperty = 123;
const int Glyphs::FillProperty = 124;
const int Control::VerticalContentAlignmentProperty = 125;
const int Control::TemplateProperty = 126;
const int Control::TabNavigationProperty = 127;
const int Control::TabIndexProperty = 128;
const int Control::PaddingProperty = 129;
const int Control::IsTemplateItemProperty = 130;
const int Control::IsTabStopProperty = 131;
const int Control::IsEnabledProperty = 132;
const int Control::HorizontalContentAlignmentProperty = 133;
const int Control::ForegroundProperty = 134;
const int Control::FontWeightProperty = 135;
const int Control::FontStyleProperty = 136;
const int Control::FontStretchProperty = 137;
const int Control::FontSizeProperty = 138;
const int Control::FontFamilyProperty = 139;
const int Control::DefaultStyleKeyProperty = 140;
const int Control::BorderThicknessProperty = 141;
const int Control::BorderBrushProperty = 142;
const int Control::BackgroundProperty = 143;
const int Panel::ChildrenProperty = 144;
const int Panel::BackgroundProperty = 145;
const int Border::PaddingProperty = 146;
const int Border::CornerRadiusProperty = 147;
const int Border::ChildProperty = 148;
const int Border::BorderThicknessProperty = 149;
const int Border::BorderBrushProperty = 150;
const int Border::BackgroundProperty = 151;
const int TimelineGroup::ChildrenProperty = 152;
const int Setter::ValueProperty = 153;
const int Setter::PropertyProperty = 154;
const int Setter::ConvertedValueProperty = 155;
const int Run::TextProperty = 156;
const int RectangleGeometry::RectProperty = 157;
const int RectangleGeometry::RadiusYProperty = 158;
const int RectangleGeometry::RadiusXProperty = 159;
const int PathGeometry::FillRuleProperty = 160;
const int PathGeometry::FiguresProperty = 161;
const int LineGeometry::StartPointProperty = 162;
const int LineGeometry::EndPointProperty = 163;
const int GeometryGroup::FillRuleProperty = 164;
const int GeometryGroup::ChildrenProperty = 165;
const int EllipseGeometry::RadiusYProperty = 166;
const int EllipseGeometry::RadiusXProperty = 167;
const int EllipseGeometry::CenterProperty = 168;
const int FrameworkElement::WidthProperty = 169;
const int FrameworkElement::VerticalAlignmentProperty = 170;
const int FrameworkElement::StyleProperty = 171;
const int FrameworkElement::MinWidthProperty = 172;
const int FrameworkElement::MinHeightProperty = 173;
const int FrameworkElement::MaxWidthProperty = 174;
const int FrameworkElement::MaxHeightProperty = 175;
const int FrameworkElement::MarginProperty = 176;
const int FrameworkElement::LanguageProperty = 177;
const int FrameworkElement::HorizontalAlignmentProperty = 178;
const int FrameworkElement::HeightProperty = 179;
const int FrameworkElement::DataContextProperty = 180;
const int FrameworkElement::ActualWidthProperty = 181;
const int FrameworkElement::ActualHeightProperty = 182;
const int PowerEase::PowerProperty = 183;
const int ExponentialEase::ExponentProperty = 184;
const int ElasticEase::SpringinessProperty = 185;
const int ElasticEase::OscillationsProperty = 186;
const int BounceEase::BouncinessProperty = 187;
const int BounceEase::BouncesProperty = 188;
const int BackEase::AmplitudeProperty = 189;
const int SplinePointKeyFrame::KeySplineProperty = 190;
const int EasingPointKeyFrame::EasingFunctionProperty = 191;
const int PointAnimationUsingKeyFrames::KeyFramesProperty = 192;
const int SplineDoubleKeyFrame::KeySplineProperty = 193;
const int EasingDoubleKeyFrame::EasingFunctionProperty = 194;
const int DoubleAnimationUsingKeyFrames::KeyFramesProperty = 195;
const int TimelineMarker::TypeProperty = 196;
const int TimelineMarker::TimeProperty = 197;
const int TimelineMarker::TextProperty = 198;
const int Timeline::SpeedRatioProperty = 199;
const int Timeline::RepeatBehaviorProperty = 200;
const int Timeline::FillBehaviorProperty = 201;
const int Timeline::DurationProperty = 202;
const int Timeline::BeginTimeProperty = 203;
const int Timeline::AutoReverseProperty = 204;
const int StylusPoint::YProperty = 205;
const int StylusPoint::XProperty = 206;
const int StylusPoint::PressureFactorProperty = 207;
const int StylusInfo::IsInvertedProperty = 208;
const int StylusInfo::DeviceTypeProperty = 209;
const int Style::TargetTypeProperty = 210;
const int Style::SettersProperty = 211;
const int Style::IsSealedProperty = 212;
const int Stroke::StylusPointsProperty = 213;
const int Stroke::DrawingAttributesProperty = 214;
const int SetterBase::IsSealedProperty = 215;
const int RowDefinition::MinHeightProperty = 216;
const int RowDefinition::MaxHeightProperty = 217;
const int RowDefinition::HeightProperty = 218;
const int RowDefinition::ActualHeightProperty = 219;
const int PathFigure::StartPointProperty = 220;
const int PathFigure::SegmentsProperty = 221;
const int PathFigure::IsFilledProperty = 222;
const int PathFigure::IsClosedProperty = 223;
const int NameScope::NameScopeProperty = 224;
const int MultiScaleSubImage::ZIndexProperty = 225;
const int MultiScaleSubImage::ViewportWidthProperty = 226;
const int MultiScaleSubImage::ViewportOriginProperty = 227;
const int MultiScaleSubImage::OpacityProperty = 228;
const int MultiScaleSubImage::AspectRatioProperty = 229;
const int MediaAttribute::ValueProperty = 230;
const int Matrix::OffsetYProperty = 231;
const int Matrix::OffsetXProperty = 232;
const int Matrix::M22Property = 233;
const int Matrix::M21Property = 234;
const int Matrix::M12Property = 235;
const int Matrix::M11Property = 236;
const int KeySpline::ControlPoint2Property = 237;
const int KeySpline::ControlPoint1Property = 238;
const int InputMethod::IsInputMethodEnabledProperty = 239;
const int Inline::TextDecorationsProperty = 240;
const int Inline::LanguageProperty = 241;
const int Inline::ForegroundProperty = 242;
const int Inline::FontWeightProperty = 243;
const int Inline::FontStyleProperty = 244;
const int Inline::FontStretchProperty = 245;
const int Inline::FontSourceProperty = 246;
const int Inline::FontSizeProperty = 247;
const int Inline::FontFamilyProperty = 248;
const int GradientStop::OffsetProperty = 249;
const int GradientStop::ColorProperty = 250;
const int Geometry::TransformProperty = 251;
const int DrawingAttributes::WidthProperty = 252;
const int DrawingAttributes::OutlineColorProperty = 253;
const int DrawingAttributes::HeightProperty = 254;
const int DrawingAttributes::ColorProperty = 255;
const int Downloader::UriProperty = 256;
const int Downloader::StatusTextProperty = 257;
const int Downloader::StatusProperty = 258;
const int Downloader::ResponseTextProperty = 259;
const int Downloader::DownloadProgressProperty = 260;
const int Deployment::SurfaceProperty = 261;
const int Deployment::RuntimeVersionProperty = 262;
const int Deployment::PartsProperty = 263;
const int Deployment::ExternalCallersFromCrossDomainProperty = 264;
const int Deployment::EntryPointTypeProperty = 265;
const int Deployment::EntryPointAssemblyProperty = 266;
const int ColumnDefinition::WidthProperty = 267;
const int ColumnDefinition::MinWidthProperty = 268;
const int ColumnDefinition::MaxWidthProperty = 269;
const int ColumnDefinition::ActualWidthProperty = 270;
const int Collection::CountProperty = 271;
const int UIElement::VisibilityProperty = 272;
const int UIElement::UseLayoutRoundingProperty = 273;
const int UIElement::TriggersProperty = 274;
const int UIElement::TagProperty = 275;
const int UIElement::ResourcesProperty = 276;
const int UIElement::RenderTransformProperty = 277;
const int UIElement::RenderTransformOriginProperty = 278;
const int UIElement::OpacityProperty = 279;
const int UIElement::OpacityMaskProperty = 280;
const int UIElement::IsHitTestVisibleProperty = 281;
const int UIElement::CursorProperty = 282;
const int UIElement::ClipProperty = 283;
const int EasingFunctionBase::EasingModeProperty = 284;
const int AssemblyPart::SourceProperty = 285;
const int Application::ResourcesProperty = 286;
const int Accessibility::TitleProperty = 287;
const int Accessibility::DescriptionProperty = 288;
const int Accessibility::ActionDescriptionProperty = 289;
const int SplineColorKeyFrame::KeySplineProperty = 290;
const int EasingColorKeyFrame::EasingFunctionProperty = 291;
const int ColorAnimationUsingKeyFrames::KeyFramesProperty = 292;
const int BitmapImage::UriSourceProperty = 293;
const int BitmapImage::ProgressProperty = 294;
const int TranslateTransform::YProperty = 295;
const int TranslateTransform::XProperty = 296;
const int TransformGroup::ChildrenProperty = 297;
const int TextBox::VerticalScrollBarVisibilityProperty = 298;
const int TextBox::TextWrappingProperty = 299;
const int TextBox::TextProperty = 300;
const int TextBox::TextAlignmentProperty = 301;
const int TextBox::SelectionStartProperty = 302;
const int TextBox::SelectionLengthProperty = 303;
const int TextBox::SelectionForegroundProperty = 304;
const int TextBox::SelectionBackgroundProperty = 305;
const int TextBox::SelectedTextProperty = 306;
const int TextBox::MaxLengthProperty = 307;
const int TextBox::IsReadOnlyProperty = 308;
const int TextBox::HorizontalScrollBarVisibilityProperty = 309;
const int TextBox::FontSourceProperty = 310;
const int TextBox::CaretBrushProperty = 311;
const int TextBox::AcceptsReturnProperty = 312;
const int Storyboard::TargetPropertyProperty = 313;
const int Storyboard::TargetNameProperty = 314;
const int SkewTransform::CenterYProperty = 315;
const int SkewTransform::CenterXProperty = 316;
const int SkewTransform::AngleYProperty = 317;
const int SkewTransform::AngleXProperty = 318;
const int SetterBaseCollection::IsSealedProperty = 319;
const int ScaleTransform::ScaleYProperty = 320;
const int ScaleTransform::ScaleXProperty = 321;
const int ScaleTransform::CenterYProperty = 322;
const int ScaleTransform::CenterXProperty = 323;
const int RotateTransform::CenterYProperty = 324;
const int RotateTransform::CenterXProperty = 325;
const int RotateTransform::AngleProperty = 326;
const int QuadraticBezierSegment::Point2Property = 327;
const int QuadraticBezierSegment::Point1Property = 328;
const int PolyQuadraticBezierSegment::PointsProperty = 329;
const int PolyLineSegment::PointsProperty = 330;
const int PolyBezierSegment::PointsProperty = 331;
const int PointKeyFrame::ValueProperty = 332;
const int PointKeyFrame::KeyTimeProperty = 333;
const int PointAnimation::ToProperty = 334;
const int PointAnimation::FromProperty = 335;
const int PointAnimation::EasingFunctionProperty = 336;
const int PointAnimation::ByProperty = 337;
const int PasswordBox::SelectionStartProperty = 338;
const int PasswordBox::SelectionLengthProperty = 339;
const int PasswordBox::SelectionForegroundProperty = 340;
const int PasswordBox::SelectionBackgroundProperty = 341;
const int PasswordBox::SelectedTextProperty = 342;
const int PasswordBox::PasswordProperty = 343;
const int PasswordBox::PasswordCharProperty = 344;
const int PasswordBox::MaxLengthProperty = 345;
const int PasswordBox::FontSourceProperty = 346;
const int PasswordBox::CaretBrushProperty = 347;
const int ObjectKeyFrame::ValueProperty = 348;
const int ObjectKeyFrame::KeyTimeProperty = 349;
const int ObjectKeyFrame::ConvertedValueProperty = 350;
const int ObjectAnimationUsingKeyFrames::KeyFramesProperty = 351;
const int MatrixTransform::MatrixProperty = 352;
const int LineSegment::PointProperty = 353;
const int LayoutInformation::LayoutSlotProperty = 354;
const int LayoutInformation::LayoutClipProperty = 355;
const int LayoutInformation::LastRenderSizeProperty = 356;
const int LayoutInformation::LastMeasureProperty = 357;
const int LayoutInformation::LastArrangeProperty = 358;
const int EventTrigger::RoutedEventProperty = 359;
const int EventTrigger::ActionsProperty = 360;
const int DoubleKeyFrame::ValueProperty = 361;
const int DoubleKeyFrame::KeyTimeProperty = 362;
const int DoubleAnimation::ToProperty = 363;
const int DoubleAnimation::FromProperty = 364;
const int DoubleAnimation::EasingFunctionProperty = 365;
const int DoubleAnimation::ByProperty = 366;
const int DependencyObject::NameProperty = 367;
const int DeepZoomImageTileSource::UriSourceProperty = 368;
const int ControlTemplate::TargetTypeProperty = 369;
const int ColorKeyFrame::ValueProperty = 370;
const int ColorKeyFrame::KeyTimeProperty = 371;
const int ColorAnimation::ToProperty = 372;
const int ColorAnimation::FromProperty = 373;
const int ColorAnimation::EasingFunctionProperty = 374;
const int ColorAnimation::ByProperty = 375;
const int BitmapSource::PixelWidthProperty = 376;
const int BitmapSource::PixelHeightProperty = 377;
const int BitmapSource::PixelFormatProperty = 378;
const int BezierSegment::Point3Property = 379;
const int BezierSegment::Point2Property = 380;
const int BezierSegment::Point1Property = 381;
const int BeginStoryboard::StoryboardProperty = 382;
const int ArcSegment::SweepDirectionProperty = 383;
const int ArcSegment::SizeProperty = 384;
const int ArcSegment::RotationAngleProperty = 385;
const int ArcSegment::PointProperty = 386;
const int ArcSegment::IsLargeArcProperty = 387;

UIElement *
VisualBrush::GetVisual ()
{
	Value *value = GetValue (VisualBrush::VisualProperty);
	return value ? value->AsUIElement () : NULL;
}

void
VisualBrush::SetVisual (UIElement *value)
{
	SetValue (VisualBrush::VisualProperty, Value::CreateUnrefPtr (value));
}

const char *
VideoBrush::GetSourceName ()
{
	Value *value = GetValue (VideoBrush::SourceNameProperty);
	return value ? value->AsString () : NULL;
}

void
VideoBrush::SetSourceName (const char *value)
{
	SetValue (VideoBrush::SourceNameProperty, Value (value));
}

ImageSource *
ImageBrush::GetImageSource ()
{
	Value *value = GetValue (ImageBrush::ImageSourceProperty);
	return value ? value->AsImageSource () : NULL;
}

void
ImageBrush::SetImageSource (ImageSource *value)
{
	SetValue (ImageBrush::ImageSourceProperty, Value::CreateUnrefPtr (value));
}

double
ImageBrush::GetDownloadProgress ()
{
	Value *value = GetValue (ImageBrush::DownloadProgressProperty);
	return value->AsDouble ();
}

void
ImageBrush::SetDownloadProgress (double value)
{
	SetValue (ImageBrush::DownloadProgressProperty, Value (value));
}

double
RadialGradientBrush::GetRadiusY ()
{
	Value *value = GetValue (RadialGradientBrush::RadiusYProperty);
	return value->AsDouble ();
}

void
RadialGradientBrush::SetRadiusY (double value)
{
	SetValue (RadialGradientBrush::RadiusYProperty, Value (value));
}

double
RadialGradientBrush::GetRadiusX ()
{
	Value *value = GetValue (RadialGradientBrush::RadiusXProperty);
	return value->AsDouble ();
}

void
RadialGradientBrush::SetRadiusX (double value)
{
	SetValue (RadialGradientBrush::RadiusXProperty, Value (value));
}

Point *
RadialGradientBrush::GetGradientOrigin ()
{
	Value *value = GetValue (RadialGradientBrush::GradientOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
RadialGradientBrush::SetGradientOrigin (Point *value)
{
	if (!value) return;
	SetValue (RadialGradientBrush::GradientOriginProperty, Value (*value));
}

Point *
RadialGradientBrush::GetCenter ()
{
	Value *value = GetValue (RadialGradientBrush::CenterProperty);
	return value ? value->AsPoint () : NULL;
}

void
RadialGradientBrush::SetCenter (Point *value)
{
	if (!value) return;
	SetValue (RadialGradientBrush::CenterProperty, Value (*value));
}

Point *
LinearGradientBrush::GetStartPoint ()
{
	Value *value = GetValue (LinearGradientBrush::StartPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LinearGradientBrush::SetStartPoint (Point *value)
{
	if (!value) return;
	SetValue (LinearGradientBrush::StartPointProperty, Value (*value));
}

Point *
LinearGradientBrush::GetEndPoint ()
{
	Value *value = GetValue (LinearGradientBrush::EndPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LinearGradientBrush::SetEndPoint (Point *value)
{
	if (!value) return;
	SetValue (LinearGradientBrush::EndPointProperty, Value (*value));
}

Color *
SolidColorBrush::GetColor ()
{
	Value *value = GetValue (SolidColorBrush::ColorProperty);
	return value ? value->AsColor () : NULL;
}

void
SolidColorBrush::SetColor (Color *value)
{
	if (!value) return;
	SetValue (SolidColorBrush::ColorProperty, Value (*value));
}

Stretch
TileBrush::GetStretch ()
{
	Value *value = GetValue (TileBrush::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
TileBrush::SetStretch (Stretch value)
{
	SetValue (TileBrush::StretchProperty, Value (value));
}

AlignmentY
TileBrush::GetAlignmentY ()
{
	Value *value = GetValue (TileBrush::AlignmentYProperty);
	return (AlignmentY) value->AsInt32 ();
}

void
TileBrush::SetAlignmentY (AlignmentY value)
{
	SetValue (TileBrush::AlignmentYProperty, Value (value));
}

AlignmentX
TileBrush::GetAlignmentX ()
{
	Value *value = GetValue (TileBrush::AlignmentXProperty);
	return (AlignmentX) value->AsInt32 ();
}

void
TileBrush::SetAlignmentX (AlignmentX value)
{
	SetValue (TileBrush::AlignmentXProperty, Value (value));
}

GradientSpreadMethod
GradientBrush::GetSpreadMethod ()
{
	Value *value = GetValue (GradientBrush::SpreadMethodProperty);
	return (GradientSpreadMethod) value->AsInt32 ();
}

void
GradientBrush::SetSpreadMethod (GradientSpreadMethod value)
{
	SetValue (GradientBrush::SpreadMethodProperty, Value (value));
}

BrushMappingMode
GradientBrush::GetMappingMode ()
{
	Value *value = GetValue (GradientBrush::MappingModeProperty);
	return (BrushMappingMode) value->AsInt32 ();
}

void
GradientBrush::SetMappingMode (BrushMappingMode value)
{
	SetValue (GradientBrush::MappingModeProperty, Value (value));
}

GradientStopCollection *
GradientBrush::GetGradientStops ()
{
	Value *value = GetValue (GradientBrush::GradientStopsProperty);
	return value ? value->AsGradientStopCollection () : NULL;
}

void
GradientBrush::SetGradientStops (GradientStopCollection *value)
{
	SetValue (GradientBrush::GradientStopsProperty, Value::CreateUnrefPtr (value));
}

ColorInterpolationMode
GradientBrush::GetColorInterpolationMode ()
{
	Value *value = GetValue (GradientBrush::ColorInterpolationModeProperty);
	return (ColorInterpolationMode) value->AsInt32 ();
}

void
GradientBrush::SetColorInterpolationMode (ColorInterpolationMode value)
{
	SetValue (GradientBrush::ColorInterpolationModeProperty, Value (value));
}

StrokeCollection *
InkPresenter::GetStrokes ()
{
	Value *value = GetValue (InkPresenter::StrokesProperty);
	return value ? value->AsStrokeCollection () : NULL;
}

void
InkPresenter::SetStrokes (StrokeCollection *value)
{
	SetValue (InkPresenter::StrokesProperty, Value::CreateUnrefPtr (value));
}

Transform *
Brush::GetTransform ()
{
	Value *value = GetValue (Brush::TransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
Brush::SetTransform (Transform *value)
{
	SetValue (Brush::TransformProperty, Value::CreateUnrefPtr (value));
}

Transform *
Brush::GetRelativeTransform ()
{
	Value *value = GetValue (Brush::RelativeTransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
Brush::SetRelativeTransform (Transform *value)
{
	SetValue (Brush::RelativeTransformProperty, Value::CreateUnrefPtr (value));
}

double
Brush::GetOpacity ()
{
	Value *value = GetValue (Brush::OpacityProperty);
	return value->AsDouble ();
}

void
Brush::SetOpacity (double value)
{
	SetValue (Brush::OpacityProperty, Value (value));
}

double
Rectangle::GetRadiusY ()
{
	Value *value = GetValue (Rectangle::RadiusYProperty);
	return value->AsDouble ();
}

void
Rectangle::SetRadiusY (double value)
{
	SetValue (Rectangle::RadiusYProperty, Value (value));
}

double
Rectangle::GetRadiusX ()
{
	Value *value = GetValue (Rectangle::RadiusXProperty);
	return value->AsDouble ();
}

void
Rectangle::SetRadiusX (double value)
{
	SetValue (Rectangle::RadiusXProperty, Value (value));
}

PointCollection *
Polyline::GetPoints ()
{
	Value *value = GetValue (Polyline::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
Polyline::SetPoints (PointCollection *value)
{
	SetValue (Polyline::PointsProperty, Value::CreateUnrefPtr (value));
}

FillRule
Polyline::GetFillRule ()
{
	Value *value = GetValue (Polyline::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
Polyline::SetFillRule (FillRule value)
{
	SetValue (Polyline::FillRuleProperty, Value (value));
}

PointCollection *
Polygon::GetPoints ()
{
	Value *value = GetValue (Polygon::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
Polygon::SetPoints (PointCollection *value)
{
	SetValue (Polygon::PointsProperty, Value::CreateUnrefPtr (value));
}

FillRule
Polygon::GetFillRule ()
{
	Value *value = GetValue (Polygon::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
Polygon::SetFillRule (FillRule value)
{
	SetValue (Polygon::FillRuleProperty, Value (value));
}

Geometry *
Path::GetData ()
{
	Value *value = GetValue (Path::DataProperty);
	return value ? value->AsGeometry () : NULL;
}

void
Path::SetData (Geometry *value)
{
	SetValue (Path::DataProperty, Value::CreateUnrefPtr (value));
}

double
Line::GetY2 ()
{
	Value *value = GetValue (Line::Y2Property);
	return value->AsDouble ();
}

void
Line::SetY2 (double value)
{
	SetValue (Line::Y2Property, Value (value));
}

double
Line::GetY1 ()
{
	Value *value = GetValue (Line::Y1Property);
	return value->AsDouble ();
}

void
Line::SetY1 (double value)
{
	SetValue (Line::Y1Property, Value (value));
}

double
Line::GetX2 ()
{
	Value *value = GetValue (Line::X2Property);
	return value->AsDouble ();
}

void
Line::SetX2 (double value)
{
	SetValue (Line::X2Property, Value (value));
}

double
Line::GetX1 ()
{
	Value *value = GetValue (Line::X1Property);
	return value->AsDouble ();
}

void
Line::SetX1 (double value)
{
	SetValue (Line::X1Property, Value (value));
}

double
MultiScaleImage::GetViewportWidth ()
{
	Value *value = GetValue (MultiScaleImage::ViewportWidthProperty);
	return value->AsDouble ();
}

void
MultiScaleImage::SetViewportWidth (double value)
{
	SetValue (MultiScaleImage::ViewportWidthProperty, Value (value));
}

Point *
MultiScaleImage::GetViewportOrigin ()
{
	Value *value = GetValue (MultiScaleImage::ViewportOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
MultiScaleImage::SetViewportOrigin (Point *value)
{
	if (!value) return;
	SetValue (MultiScaleImage::ViewportOriginProperty, Value (*value));
}

bool
MultiScaleImage::GetUseSprings ()
{
	Value *value = GetValue (MultiScaleImage::UseSpringsProperty);
	return value->AsBool ();
}

void
MultiScaleImage::SetUseSprings (bool value)
{
	SetValue (MultiScaleImage::UseSpringsProperty, Value (value));
}

MultiScaleSubImageCollection *
MultiScaleImage::GetSubImages ()
{
	Value *value = GetValue (MultiScaleImage::SubImagesProperty);
	return value ? value->AsMultiScaleSubImageCollection () : NULL;
}

MultiScaleTileSource *
MultiScaleImage::GetSource ()
{
	Value *value = GetValue (MultiScaleImage::SourceProperty);
	return value ? value->AsMultiScaleTileSource () : NULL;
}

void
MultiScaleImage::SetSource (MultiScaleTileSource *value)
{
	SetValue (MultiScaleImage::SourceProperty, Value::CreateUnrefPtr (value));
}

bool
MultiScaleImage::GetIsIdle ()
{
	Value *value = GetValue (MultiScaleImage::IsIdleProperty);
	return value->AsBool ();
}

bool
MultiScaleImage::GetIsDownloading ()
{
	Value *value = GetValue (MultiScaleImage::IsDownloadingProperty);
	return value->AsBool ();
}

double
MultiScaleImage::GetInternalViewportWidth ()
{
	Value *value = GetValue (MultiScaleImage::InternalViewportWidthProperty);
	return value->AsDouble ();
}

Point *
MultiScaleImage::GetInternalViewportOrigin ()
{
	Value *value = GetValue (MultiScaleImage::InternalViewportOriginProperty);
	return value ? value->AsPoint () : NULL;
}

double
MultiScaleImage::GetBlurFactor ()
{
	Value *value = GetValue (MultiScaleImage::BlurFactorProperty);
	return value->AsDouble ();
}

void
MultiScaleImage::SetBlurFactor (double value)
{
	SetValue (MultiScaleImage::BlurFactorProperty, Value (value));
}

double
MultiScaleImage::GetAspectRatio ()
{
	Value *value = GetValue (MultiScaleImage::AspectRatioProperty);
	return value->AsDouble ();
}

bool
MultiScaleImage::GetAllowDownloading ()
{
	Value *value = GetValue (MultiScaleImage::AllowDownloadingProperty);
	return value->AsBool ();
}

void
MultiScaleImage::SetAllowDownloading (bool value)
{
	SetValue (MultiScaleImage::AllowDownloadingProperty, Value (value));
}

ImageSource *
Image::GetSource ()
{
	Value *value = GetValue (Image::SourceProperty);
	return value ? value->AsImageSource () : NULL;
}

void
Image::SetSource (ImageSource *value)
{
	SetValue (Image::SourceProperty, Value::CreateUnrefPtr (value));
}

DataTemplate *
ContentControl::GetContentTemplate ()
{
	Value *value = GetValue (ContentControl::ContentTemplateProperty);
	return value ? value->AsDataTemplate () : NULL;
}

void
ContentControl::SetContentTemplate (DataTemplate *value)
{
	SetValue (ContentControl::ContentTemplateProperty, Value::CreateUnrefPtr (value));
}

bool
Grid::GetShowGridLines ()
{
	Value *value = GetValue (Grid::ShowGridLinesProperty);
	return value->AsBool ();
}

void
Grid::SetShowGridLines (bool value)
{
	SetValue (Grid::ShowGridLinesProperty, Value (value));
}

gint32
Grid::GetRowSpan (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::RowSpanProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::RowSpanProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetRowSpan (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::RowSpanProperty, Value (value));
}

gint32
Grid::GetRow (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::RowProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::RowProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetRow (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::RowProperty, Value (value));
}

RowDefinitionCollection *
Grid::GetRowDefinitions ()
{
	Value *value = GetValue (Grid::RowDefinitionsProperty);
	return value ? value->AsRowDefinitionCollection () : NULL;
}

void
Grid::SetRowDefinitions (RowDefinitionCollection *value)
{
	SetValue (Grid::RowDefinitionsProperty, Value::CreateUnrefPtr (value));
}

gint32
Grid::GetColumnSpan (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::ColumnSpanProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::ColumnSpanProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetColumnSpan (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::ColumnSpanProperty, Value (value));
}

gint32
Grid::GetColumn (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::ColumnProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::ColumnProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetColumn (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::ColumnProperty, Value (value));
}

ColumnDefinitionCollection *
Grid::GetColumnDefinitions ()
{
	Value *value = GetValue (Grid::ColumnDefinitionsProperty);
	return value ? value->AsColumnDefinitionCollection () : NULL;
}

void
Grid::SetColumnDefinitions (ColumnDefinitionCollection *value)
{
	SetValue (Grid::ColumnDefinitionsProperty, Value::CreateUnrefPtr (value));
}

gint32
Canvas::GetZIndex (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Canvas::ZIndexProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Canvas::ZIndexProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Canvas::SetZIndex (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Canvas::ZIndexProperty, Value (value));
}

double
Canvas::GetTop (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Canvas::TopProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Canvas::TopProperty)->GetDefaultValue();
	return value->AsDouble ();
}

void
Canvas::SetTop (DependencyObject *obj, double value)
{
	if (!obj) return;
	obj->SetValue (Canvas::TopProperty, Value (value));
}

double
Canvas::GetLeft (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Canvas::LeftProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Canvas::LeftProperty)->GetDefaultValue();
	return value->AsDouble ();
}

void
Canvas::SetLeft (DependencyObject *obj, double value)
{
	if (!obj) return;
	obj->SetValue (Canvas::LeftProperty, Value (value));
}

TextWrapping
TextBlock::GetTextWrapping ()
{
	Value *value = GetValue (TextBlock::TextWrappingProperty);
	return (TextWrapping) value->AsInt32 ();
}

void
TextBlock::SetTextWrapping (TextWrapping value)
{
	SetValue (TextBlock::TextWrappingProperty, Value (value));
}

const char *
TextBlock::GetText ()
{
	Value *value = GetValue (TextBlock::TextProperty);
	return value ? value->AsString () : NULL;
}

void
TextBlock::SetText (const char *value)
{
	SetValue (TextBlock::TextProperty, Value (value));
}

TextDecorations
TextBlock::GetTextDecorations ()
{
	Value *value = GetValue (TextBlock::TextDecorationsProperty);
	return (TextDecorations) value->AsInt32 ();
}

void
TextBlock::SetTextDecorations (TextDecorations value)
{
	SetValue (TextBlock::TextDecorationsProperty, Value (value));
}

TextAlignment
TextBlock::GetTextAlignment ()
{
	Value *value = GetValue (TextBlock::TextAlignmentProperty);
	return (TextAlignment) value->AsInt32 ();
}

void
TextBlock::SetTextAlignment (TextAlignment value)
{
	SetValue (TextBlock::TextAlignmentProperty, Value (value));
}

Thickness *
TextBlock::GetPadding ()
{
	Value *value = GetValue (TextBlock::PaddingProperty);
	return value ? value->AsThickness () : NULL;
}

void
TextBlock::SetPadding (Thickness *value)
{
	if (!value) return;
	SetValue (TextBlock::PaddingProperty, Value (*value));
}

LineStackingStrategy
TextBlock::GetLineStackingStrategy ()
{
	Value *value = GetValue (TextBlock::LineStackingStrategyProperty);
	return (LineStackingStrategy) value->AsInt32 ();
}

void
TextBlock::SetLineStackingStrategy (LineStackingStrategy value)
{
	SetValue (TextBlock::LineStackingStrategyProperty, Value (value));
}

double
TextBlock::GetLineHeight ()
{
	Value *value = GetValue (TextBlock::LineHeightProperty);
	return value->AsDouble ();
}

void
TextBlock::SetLineHeight (double value)
{
	SetValue (TextBlock::LineHeightProperty, Value (value));
}

InlineCollection *
TextBlock::GetInlines ()
{
	Value *value = GetValue (TextBlock::InlinesProperty);
	return value ? value->AsInlineCollection () : NULL;
}

void
TextBlock::SetInlines (InlineCollection *value)
{
	SetValue (TextBlock::InlinesProperty, Value::CreateUnrefPtr (value));
}

Brush *
TextBlock::GetForeground ()
{
	Value *value = GetValue (TextBlock::ForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBlock::SetForeground (Brush *value)
{
	SetValue (TextBlock::ForegroundProperty, Value::CreateUnrefPtr (value));
}

FontWeight *
TextBlock::GetFontWeight ()
{
	Value *value = GetValue (TextBlock::FontWeightProperty);
	return value ? value->AsFontWeight () : NULL;
}

void
TextBlock::SetFontWeight (FontWeight *value)
{
	if (!value) return;
	SetValue (TextBlock::FontWeightProperty, Value (*value));
}

FontStyle *
TextBlock::GetFontStyle ()
{
	Value *value = GetValue (TextBlock::FontStyleProperty);
	return value ? value->AsFontStyle () : NULL;
}

void
TextBlock::SetFontStyle (FontStyle *value)
{
	if (!value) return;
	SetValue (TextBlock::FontStyleProperty, Value (*value));
}

FontStretch *
TextBlock::GetFontStretch ()
{
	Value *value = GetValue (TextBlock::FontStretchProperty);
	return value ? value->AsFontStretch () : NULL;
}

void
TextBlock::SetFontStretch (FontStretch *value)
{
	if (!value) return;
	SetValue (TextBlock::FontStretchProperty, Value (*value));
}

FontSource *
TextBlock::GetFontSource ()
{
	Value *value = GetValue (TextBlock::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
TextBlock::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (TextBlock::FontSourceProperty, Value (*value));
}

double
TextBlock::GetFontSize ()
{
	Value *value = GetValue (TextBlock::FontSizeProperty);
	return value->AsDouble ();
}

void
TextBlock::SetFontSize (double value)
{
	SetValue (TextBlock::FontSizeProperty, Value (value));
}

FontFamily *
TextBlock::GetFontFamily ()
{
	Value *value = GetValue (TextBlock::FontFamilyProperty);
	return value ? value->AsFontFamily () : NULL;
}

void
TextBlock::SetFontFamily (FontFamily *value)
{
	if (!value) return;
	SetValue (TextBlock::FontFamilyProperty, Value (*value));
}

double
Popup::GetVerticalOffset ()
{
	Value *value = GetValue (Popup::VerticalOffsetProperty);
	return value->AsDouble ();
}

void
Popup::SetVerticalOffset (double value)
{
	SetValue (Popup::VerticalOffsetProperty, Value (value));
}

bool
Popup::GetIsOpen ()
{
	Value *value = GetValue (Popup::IsOpenProperty);
	return value->AsBool ();
}

void
Popup::SetIsOpen (bool value)
{
	SetValue (Popup::IsOpenProperty, Value (value));
}

double
Popup::GetHorizontalOffset ()
{
	Value *value = GetValue (Popup::HorizontalOffsetProperty);
	return value->AsDouble ();
}

void
Popup::SetHorizontalOffset (double value)
{
	SetValue (Popup::HorizontalOffsetProperty, Value (value));
}

UIElement *
Popup::GetChild ()
{
	Value *value = GetValue (Popup::ChildProperty);
	return value ? value->AsUIElement () : NULL;
}

void
Popup::SetChild (UIElement *value)
{
	SetValue (Popup::ChildProperty, Value::CreateUnrefPtr (value));
}

double
MediaElement::GetVolume ()
{
	Value *value = GetValue (MediaElement::VolumeProperty);
	return value->AsDouble ();
}

void
MediaElement::SetVolume (double value)
{
	SetValue (MediaElement::VolumeProperty, Value (value));
}

Stretch
MediaElement::GetStretch ()
{
	Value *value = GetValue (MediaElement::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
MediaElement::SetStretch (Stretch value)
{
	SetValue (MediaElement::StretchProperty, Value (value));
}

Uri *
MediaElement::GetSource ()
{
	Value *value = GetValue (MediaElement::SourceProperty);
	return value ? value->AsUri () : NULL;
}

void
MediaElement::SetSource (Uri *value)
{
	if (!value) return;
	SetValue (MediaElement::SourceProperty, Value (*value));
}

double
MediaElement::GetRenderedFramesPerSecond ()
{
	Value *value = GetValue (MediaElement::RenderedFramesPerSecondProperty);
	return value->AsDouble ();
}

void
MediaElement::SetRenderedFramesPerSecond (double value)
{
	SetValue (MediaElement::RenderedFramesPerSecondProperty, Value (value));
}

TimeSpan
MediaElement::GetPosition ()
{
	Value *value = GetValue (MediaElement::PositionProperty);
	return value->AsTimeSpan ();
}

void
MediaElement::SetPosition (TimeSpan value)
{
	SetValue (MediaElement::PositionProperty, Value (value, Type::TIMESPAN));
}

gint32
MediaElement::GetNaturalVideoWidth ()
{
	Value *value = GetValue (MediaElement::NaturalVideoWidthProperty);
	return value->AsInt32 ();
}

void
MediaElement::SetNaturalVideoWidth (gint32 value)
{
	SetValue (MediaElement::NaturalVideoWidthProperty, Value (value));
}

gint32
MediaElement::GetNaturalVideoHeight ()
{
	Value *value = GetValue (MediaElement::NaturalVideoHeightProperty);
	return value->AsInt32 ();
}

void
MediaElement::SetNaturalVideoHeight (gint32 value)
{
	SetValue (MediaElement::NaturalVideoHeightProperty, Value (value));
}

Duration *
MediaElement::GetNaturalDuration ()
{
	Value *value = GetValue (MediaElement::NaturalDurationProperty);
	return value ? value->AsDuration () : NULL;
}

void
MediaElement::SetNaturalDuration (Duration *value)
{
	if (!value) return;
	SetValue (MediaElement::NaturalDurationProperty, Value (*value));
}

TimelineMarkerCollection *
MediaElement::GetMarkers ()
{
	Value *value = GetValue (MediaElement::MarkersProperty);
	return value ? value->AsTimelineMarkerCollection () : NULL;
}

void
MediaElement::SetMarkers (TimelineMarkerCollection *value)
{
	SetValue (MediaElement::MarkersProperty, Value::CreateUnrefPtr (value));
}

bool
MediaElement::GetIsMuted ()
{
	Value *value = GetValue (MediaElement::IsMutedProperty);
	return value->AsBool ();
}

void
MediaElement::SetIsMuted (bool value)
{
	SetValue (MediaElement::IsMutedProperty, Value (value));
}

double
MediaElement::GetDroppedFramesPerSecond ()
{
	Value *value = GetValue (MediaElement::DroppedFramesPerSecondProperty);
	return value->AsDouble ();
}

void
MediaElement::SetDroppedFramesPerSecond (double value)
{
	SetValue (MediaElement::DroppedFramesPerSecondProperty, Value (value));
}

double
MediaElement::GetDownloadProgress ()
{
	Value *value = GetValue (MediaElement::DownloadProgressProperty);
	return value->AsDouble ();
}

void
MediaElement::SetDownloadProgress (double value)
{
	SetValue (MediaElement::DownloadProgressProperty, Value (value));
}

double
MediaElement::GetDownloadProgressOffset ()
{
	Value *value = GetValue (MediaElement::DownloadProgressOffsetProperty);
	return value->AsDouble ();
}

void
MediaElement::SetDownloadProgressOffset (double value)
{
	SetValue (MediaElement::DownloadProgressOffsetProperty, Value (value));
}

MediaState
MediaElement::GetCurrentState ()
{
	Value *value = GetValue (MediaElement::CurrentStateProperty);
	return (MediaState) value->AsInt32 ();
}

void
MediaElement::SetCurrentState (MediaState value)
{
	SetValue (MediaElement::CurrentStateProperty, Value (value));
}

bool
MediaElement::GetCanSeek ()
{
	Value *value = GetValue (MediaElement::CanSeekProperty);
	return value->AsBool ();
}

void
MediaElement::SetCanSeek (bool value)
{
	SetValue (MediaElement::CanSeekProperty, Value (value));
}

bool
MediaElement::GetCanPause ()
{
	Value *value = GetValue (MediaElement::CanPauseProperty);
	return value->AsBool ();
}

void
MediaElement::SetCanPause (bool value)
{
	SetValue (MediaElement::CanPauseProperty, Value (value));
}

TimeSpan
MediaElement::GetBufferingTime ()
{
	Value *value = GetValue (MediaElement::BufferingTimeProperty);
	return value->AsTimeSpan ();
}

void
MediaElement::SetBufferingTime (TimeSpan value)
{
	SetValue (MediaElement::BufferingTimeProperty, Value (value, Type::TIMESPAN));
}

double
MediaElement::GetBufferingProgress ()
{
	Value *value = GetValue (MediaElement::BufferingProgressProperty);
	return value->AsDouble ();
}

void
MediaElement::SetBufferingProgress (double value)
{
	SetValue (MediaElement::BufferingProgressProperty, Value (value));
}

double
MediaElement::GetBalance ()
{
	Value *value = GetValue (MediaElement::BalanceProperty);
	return value->AsDouble ();
}

void
MediaElement::SetBalance (double value)
{
	SetValue (MediaElement::BalanceProperty, Value (value));
}

bool
MediaElement::GetAutoPlay ()
{
	Value *value = GetValue (MediaElement::AutoPlayProperty);
	return value->AsBool ();
}

void
MediaElement::SetAutoPlay (bool value)
{
	SetValue (MediaElement::AutoPlayProperty, Value (value));
}

gint32 *
MediaElement::GetAudioStreamIndex ()
{
	Value *value = GetValue (MediaElement::AudioStreamIndexProperty);
	return value ? value->AsNullableInt32 () : NULL;
}

void
MediaElement::SetAudioStreamIndex (gint32 value)
{
	SetValue (MediaElement::AudioStreamIndexProperty, Value (value));
}

void
MediaElement::SetAudioStreamIndex (gint32 * value)
{
	if (!value)
		SetValue (MediaElement::AudioStreamIndexProperty, NULL);
	else
		SetValue (MediaElement::AudioStreamIndexProperty, Value (*value));
}

gint32
MediaElement::GetAudioStreamCount ()
{
	Value *value = GetValue (MediaElement::AudioStreamCountProperty);
	return value->AsInt32 ();
}

void
MediaElement::SetAudioStreamCount (gint32 value)
{
	SetValue (MediaElement::AudioStreamCountProperty, Value (value));
}

MediaAttributeCollection *
MediaElement::GetAttributes ()
{
	Value *value = GetValue (MediaElement::AttributesProperty);
	return value ? value->AsMediaAttributeCollection () : NULL;
}

void
MediaElement::SetAttributes (MediaAttributeCollection *value)
{
	SetValue (MediaElement::AttributesProperty, Value::CreateUnrefPtr (value));
}

double
Shape::GetStrokeThickness ()
{
	Value *value = GetValue (Shape::StrokeThicknessProperty);
	return value->AsDouble ();
}

void
Shape::SetStrokeThickness (double value)
{
	SetValue (Shape::StrokeThicknessProperty, Value (value));
}

PenLineCap
Shape::GetStrokeStartLineCap ()
{
	Value *value = GetValue (Shape::StrokeStartLineCapProperty);
	return (PenLineCap) value->AsInt32 ();
}

void
Shape::SetStrokeStartLineCap (PenLineCap value)
{
	SetValue (Shape::StrokeStartLineCapProperty, Value (value));
}

Brush *
Shape::GetStroke ()
{
	Value *value = GetValue (Shape::StrokeProperty);
	return value ? value->AsBrush () : NULL;
}

void
Shape::SetStroke (Brush *value)
{
	SetValue (Shape::StrokeProperty, Value::CreateUnrefPtr (value));
}

double
Shape::GetStrokeMiterLimit ()
{
	Value *value = GetValue (Shape::StrokeMiterLimitProperty);
	return value->AsDouble ();
}

void
Shape::SetStrokeMiterLimit (double value)
{
	SetValue (Shape::StrokeMiterLimitProperty, Value (value));
}

PenLineJoin
Shape::GetStrokeLineJoin ()
{
	Value *value = GetValue (Shape::StrokeLineJoinProperty);
	return (PenLineJoin) value->AsInt32 ();
}

void
Shape::SetStrokeLineJoin (PenLineJoin value)
{
	SetValue (Shape::StrokeLineJoinProperty, Value (value));
}

PenLineCap
Shape::GetStrokeEndLineCap ()
{
	Value *value = GetValue (Shape::StrokeEndLineCapProperty);
	return (PenLineCap) value->AsInt32 ();
}

void
Shape::SetStrokeEndLineCap (PenLineCap value)
{
	SetValue (Shape::StrokeEndLineCapProperty, Value (value));
}

double
Shape::GetStrokeDashOffset ()
{
	Value *value = GetValue (Shape::StrokeDashOffsetProperty);
	return value->AsDouble ();
}

void
Shape::SetStrokeDashOffset (double value)
{
	SetValue (Shape::StrokeDashOffsetProperty, Value (value));
}

PenLineCap
Shape::GetStrokeDashCap ()
{
	Value *value = GetValue (Shape::StrokeDashCapProperty);
	return (PenLineCap) value->AsInt32 ();
}

void
Shape::SetStrokeDashCap (PenLineCap value)
{
	SetValue (Shape::StrokeDashCapProperty, Value (value));
}

DoubleCollection *
Shape::GetStrokeDashArray ()
{
	Value *value = GetValue (Shape::StrokeDashArrayProperty);
	return value ? value->AsDoubleCollection () : NULL;
}

void
Shape::SetStrokeDashArray (DoubleCollection *value)
{
	SetValue (Shape::StrokeDashArrayProperty, Value::CreateUnrefPtr (value));
}

Stretch
Shape::GetStretch ()
{
	Value *value = GetValue (Shape::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
Shape::SetStretch (Stretch value)
{
	SetValue (Shape::StretchProperty, Value (value));
}

Brush *
Shape::GetFill ()
{
	Value *value = GetValue (Shape::FillProperty);
	return value ? value->AsBrush () : NULL;
}

void
Shape::SetFill (Brush *value)
{
	SetValue (Shape::FillProperty, Value::CreateUnrefPtr (value));
}

Stretch
MediaBase::GetStretch ()
{
	Value *value = GetValue (MediaBase::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
MediaBase::SetStretch (Stretch value)
{
	SetValue (MediaBase::StretchProperty, Value (value));
}

const char *
MediaBase::GetSource ()
{
	Value *value = GetValue (MediaBase::SourceProperty);
	return value ? value->AsString () : NULL;
}

void
MediaBase::SetSource (const char *value)
{
	SetValue (MediaBase::SourceProperty, Value (value));
}

double
MediaBase::GetDownloadProgress ()
{
	Value *value = GetValue (MediaBase::DownloadProgressProperty);
	return value->AsDouble ();
}

void
MediaBase::SetDownloadProgress (double value)
{
	SetValue (MediaBase::DownloadProgressProperty, Value (value));
}

const char *
Glyphs::GetUnicodeString ()
{
	Value *value = GetValue (Glyphs::UnicodeStringProperty);
	return value ? value->AsString () : NULL;
}

void
Glyphs::SetUnicodeString (const char *value)
{
	SetValue (Glyphs::UnicodeStringProperty, Value (value));
}

StyleSimulations
Glyphs::GetStyleSimulations ()
{
	Value *value = GetValue (Glyphs::StyleSimulationsProperty);
	return (StyleSimulations) value->AsInt32 ();
}

void
Glyphs::SetStyleSimulations (StyleSimulations value)
{
	SetValue (Glyphs::StyleSimulationsProperty, Value (value));
}

double
Glyphs::GetOriginY ()
{
	Value *value = GetValue (Glyphs::OriginYProperty);
	return value->AsDouble ();
}

void
Glyphs::SetOriginY (double value)
{
	SetValue (Glyphs::OriginYProperty, Value (value));
}

double
Glyphs::GetOriginX ()
{
	Value *value = GetValue (Glyphs::OriginXProperty);
	return value->AsDouble ();
}

void
Glyphs::SetOriginX (double value)
{
	SetValue (Glyphs::OriginXProperty, Value (value));
}

const char *
Glyphs::GetIndices ()
{
	Value *value = GetValue (Glyphs::IndicesProperty);
	return value ? value->AsString () : NULL;
}

void
Glyphs::SetIndices (const char *value)
{
	SetValue (Glyphs::IndicesProperty, Value (value));
}

Uri *
Glyphs::GetFontUri ()
{
	Value *value = GetValue (Glyphs::FontUriProperty);
	return value ? value->AsUri () : NULL;
}

void
Glyphs::SetFontUri (Uri *value)
{
	if (!value) return;
	SetValue (Glyphs::FontUriProperty, Value (*value));
}

double
Glyphs::GetFontRenderingEmSize ()
{
	Value *value = GetValue (Glyphs::FontRenderingEmSizeProperty);
	return value->AsDouble ();
}

void
Glyphs::SetFontRenderingEmSize (double value)
{
	SetValue (Glyphs::FontRenderingEmSizeProperty, Value (value));
}

Brush *
Glyphs::GetFill ()
{
	Value *value = GetValue (Glyphs::FillProperty);
	return value ? value->AsBrush () : NULL;
}

void
Glyphs::SetFill (Brush *value)
{
	SetValue (Glyphs::FillProperty, Value::CreateUnrefPtr (value));
}

VerticalAlignment
Control::GetVerticalContentAlignment ()
{
	Value *value = GetValue (Control::VerticalContentAlignmentProperty);
	return (VerticalAlignment) value->AsInt32 ();
}

void
Control::SetVerticalContentAlignment (VerticalAlignment value)
{
	SetValue (Control::VerticalContentAlignmentProperty, Value (value));
}

ControlTemplate *
Control::GetTemplate ()
{
	Value *value = GetValue (Control::TemplateProperty);
	return value ? value->AsControlTemplate () : NULL;
}

void
Control::SetTemplate (ControlTemplate *value)
{
	SetValue (Control::TemplateProperty, Value::CreateUnrefPtr (value));
}

KeyboardNavigationMode
Control::GetTabNavigation ()
{
	Value *value = GetValue (Control::TabNavigationProperty);
	return (KeyboardNavigationMode) value->AsInt32 ();
}

void
Control::SetTabNavigation (KeyboardNavigationMode value)
{
	SetValue (Control::TabNavigationProperty, Value (value));
}

gint32
Control::GetTabIndex ()
{
	Value *value = GetValue (Control::TabIndexProperty);
	return value->AsInt32 ();
}

void
Control::SetTabIndex (gint32 value)
{
	SetValue (Control::TabIndexProperty, Value (value));
}

Thickness *
Control::GetPadding ()
{
	Value *value = GetValue (Control::PaddingProperty);
	return value ? value->AsThickness () : NULL;
}

void
Control::SetPadding (Thickness *value)
{
	if (!value) return;
	SetValue (Control::PaddingProperty, Value (*value));
}

bool
Control::GetIsTemplateItem (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Control::IsTemplateItemProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Control::IsTemplateItemProperty)->GetDefaultValue();
	return value->AsBool ();
}

void
Control::SetIsTemplateItem (DependencyObject *obj, bool value)
{
	if (!obj) return;
	obj->SetValue (Control::IsTemplateItemProperty, Value (value));
}

bool
Control::GetIsTabStop ()
{
	Value *value = GetValue (Control::IsTabStopProperty);
	return value->AsBool ();
}

void
Control::SetIsTabStop (bool value)
{
	SetValue (Control::IsTabStopProperty, Value (value));
}

bool
Control::GetIsEnabled ()
{
	Value *value = GetValue (Control::IsEnabledProperty);
	return value->AsBool ();
}

void
Control::SetIsEnabled (bool value)
{
	SetValue (Control::IsEnabledProperty, Value (value));
}

HorizontalAlignment
Control::GetHorizontalContentAlignment ()
{
	Value *value = GetValue (Control::HorizontalContentAlignmentProperty);
	return (HorizontalAlignment) value->AsInt32 ();
}

void
Control::SetHorizontalContentAlignment (HorizontalAlignment value)
{
	SetValue (Control::HorizontalContentAlignmentProperty, Value (value));
}

Brush *
Control::GetForeground ()
{
	Value *value = GetValue (Control::ForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Control::SetForeground (Brush *value)
{
	SetValue (Control::ForegroundProperty, Value::CreateUnrefPtr (value));
}

FontWeight *
Control::GetFontWeight ()
{
	Value *value = GetValue (Control::FontWeightProperty);
	return value ? value->AsFontWeight () : NULL;
}

void
Control::SetFontWeight (FontWeight *value)
{
	if (!value) return;
	SetValue (Control::FontWeightProperty, Value (*value));
}

FontStyle *
Control::GetFontStyle ()
{
	Value *value = GetValue (Control::FontStyleProperty);
	return value ? value->AsFontStyle () : NULL;
}

void
Control::SetFontStyle (FontStyle *value)
{
	if (!value) return;
	SetValue (Control::FontStyleProperty, Value (*value));
}

FontStretch *
Control::GetFontStretch ()
{
	Value *value = GetValue (Control::FontStretchProperty);
	return value ? value->AsFontStretch () : NULL;
}

void
Control::SetFontStretch (FontStretch *value)
{
	if (!value) return;
	SetValue (Control::FontStretchProperty, Value (*value));
}

double
Control::GetFontSize ()
{
	Value *value = GetValue (Control::FontSizeProperty);
	return value->AsDouble ();
}

void
Control::SetFontSize (double value)
{
	SetValue (Control::FontSizeProperty, Value (value));
}

FontFamily *
Control::GetFontFamily ()
{
	Value *value = GetValue (Control::FontFamilyProperty);
	return value ? value->AsFontFamily () : NULL;
}

void
Control::SetFontFamily (FontFamily *value)
{
	if (!value) return;
	SetValue (Control::FontFamilyProperty, Value (*value));
}

ManagedTypeInfo *
Control::GetDefaultStyleKey ()
{
	Value *value = GetValue (Control::DefaultStyleKeyProperty);
	return value ? value->AsManagedTypeInfo () : NULL;
}

void
Control::SetDefaultStyleKey (ManagedTypeInfo *value)
{
	if (!value) return;
	SetValue (Control::DefaultStyleKeyProperty, Value (*value));
}

Thickness *
Control::GetBorderThickness ()
{
	Value *value = GetValue (Control::BorderThicknessProperty);
	return value ? value->AsThickness () : NULL;
}

void
Control::SetBorderThickness (Thickness *value)
{
	if (!value) return;
	SetValue (Control::BorderThicknessProperty, Value (*value));
}

Brush *
Control::GetBorderBrush ()
{
	Value *value = GetValue (Control::BorderBrushProperty);
	return value ? value->AsBrush () : NULL;
}

void
Control::SetBorderBrush (Brush *value)
{
	SetValue (Control::BorderBrushProperty, Value::CreateUnrefPtr (value));
}

Brush *
Control::GetBackground ()
{
	Value *value = GetValue (Control::BackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Control::SetBackground (Brush *value)
{
	SetValue (Control::BackgroundProperty, Value::CreateUnrefPtr (value));
}

UIElementCollection *
Panel::GetChildren ()
{
	Value *value = GetValue (Panel::ChildrenProperty);
	return value ? value->AsUIElementCollection () : NULL;
}

void
Panel::SetChildren (UIElementCollection *value)
{
	SetValue (Panel::ChildrenProperty, Value::CreateUnrefPtr (value));
}

Brush *
Panel::GetBackground ()
{
	Value *value = GetValue (Panel::BackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Panel::SetBackground (Brush *value)
{
	SetValue (Panel::BackgroundProperty, Value::CreateUnrefPtr (value));
}

Thickness *
Border::GetPadding ()
{
	Value *value = GetValue (Border::PaddingProperty);
	return value ? value->AsThickness () : NULL;
}

void
Border::SetPadding (Thickness *value)
{
	if (!value) return;
	SetValue (Border::PaddingProperty, Value (*value));
}

CornerRadius *
Border::GetCornerRadius ()
{
	Value *value = GetValue (Border::CornerRadiusProperty);
	return value ? value->AsCornerRadius () : NULL;
}

void
Border::SetCornerRadius (CornerRadius *value)
{
	if (!value) return;
	SetValue (Border::CornerRadiusProperty, Value (*value));
}

UIElement *
Border::GetChild ()
{
	Value *value = GetValue (Border::ChildProperty);
	return value ? value->AsUIElement () : NULL;
}

void
Border::SetChild (UIElement *value)
{
	SetValue (Border::ChildProperty, Value::CreateUnrefPtr (value));
}

Thickness *
Border::GetBorderThickness ()
{
	Value *value = GetValue (Border::BorderThicknessProperty);
	return value ? value->AsThickness () : NULL;
}

void
Border::SetBorderThickness (Thickness *value)
{
	if (!value) return;
	SetValue (Border::BorderThicknessProperty, Value (*value));
}

Brush *
Border::GetBorderBrush ()
{
	Value *value = GetValue (Border::BorderBrushProperty);
	return value ? value->AsBrush () : NULL;
}

void
Border::SetBorderBrush (Brush *value)
{
	SetValue (Border::BorderBrushProperty, Value::CreateUnrefPtr (value));
}

Brush *
Border::GetBackground ()
{
	Value *value = GetValue (Border::BackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Border::SetBackground (Brush *value)
{
	SetValue (Border::BackgroundProperty, Value::CreateUnrefPtr (value));
}

TimelineCollection *
TimelineGroup::GetChildren ()
{
	Value *value = GetValue (TimelineGroup::ChildrenProperty);
	return value ? value->AsTimelineCollection () : NULL;
}

void
TimelineGroup::SetChildren (TimelineCollection *value)
{
	SetValue (TimelineGroup::ChildrenProperty, Value::CreateUnrefPtr (value));
}

const char *
Run::GetText ()
{
	Value *value = GetValue (Run::TextProperty);
	return value ? value->AsString () : NULL;
}

void
Run::SetText (const char *value)
{
	SetValue (Run::TextProperty, Value (value));
}

Rect *
RectangleGeometry::GetRect ()
{
	Value *value = GetValue (RectangleGeometry::RectProperty);
	return value ? value->AsRect () : NULL;
}

void
RectangleGeometry::SetRect (Rect *value)
{
	if (!value) return;
	SetValue (RectangleGeometry::RectProperty, Value (*value));
}

double
RectangleGeometry::GetRadiusY ()
{
	Value *value = GetValue (RectangleGeometry::RadiusYProperty);
	return value->AsDouble ();
}

void
RectangleGeometry::SetRadiusY (double value)
{
	SetValue (RectangleGeometry::RadiusYProperty, Value (value));
}

double
RectangleGeometry::GetRadiusX ()
{
	Value *value = GetValue (RectangleGeometry::RadiusXProperty);
	return value->AsDouble ();
}

void
RectangleGeometry::SetRadiusX (double value)
{
	SetValue (RectangleGeometry::RadiusXProperty, Value (value));
}

FillRule
PathGeometry::GetFillRule ()
{
	Value *value = GetValue (PathGeometry::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
PathGeometry::SetFillRule (FillRule value)
{
	SetValue (PathGeometry::FillRuleProperty, Value (value));
}

PathFigureCollection *
PathGeometry::GetFigures ()
{
	Value *value = GetValue (PathGeometry::FiguresProperty);
	return value ? value->AsPathFigureCollection () : NULL;
}

void
PathGeometry::SetFigures (PathFigureCollection *value)
{
	SetValue (PathGeometry::FiguresProperty, Value::CreateUnrefPtr (value));
}

Point *
LineGeometry::GetStartPoint ()
{
	Value *value = GetValue (LineGeometry::StartPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LineGeometry::SetStartPoint (Point *value)
{
	if (!value) return;
	SetValue (LineGeometry::StartPointProperty, Value (*value));
}

Point *
LineGeometry::GetEndPoint ()
{
	Value *value = GetValue (LineGeometry::EndPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LineGeometry::SetEndPoint (Point *value)
{
	if (!value) return;
	SetValue (LineGeometry::EndPointProperty, Value (*value));
}

FillRule
GeometryGroup::GetFillRule ()
{
	Value *value = GetValue (GeometryGroup::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
GeometryGroup::SetFillRule (FillRule value)
{
	SetValue (GeometryGroup::FillRuleProperty, Value (value));
}

GeometryCollection *
GeometryGroup::GetChildren ()
{
	Value *value = GetValue (GeometryGroup::ChildrenProperty);
	return value ? value->AsGeometryCollection () : NULL;
}

void
GeometryGroup::SetChildren (GeometryCollection *value)
{
	SetValue (GeometryGroup::ChildrenProperty, Value::CreateUnrefPtr (value));
}

double
EllipseGeometry::GetRadiusY ()
{
	Value *value = GetValue (EllipseGeometry::RadiusYProperty);
	return value->AsDouble ();
}

void
EllipseGeometry::SetRadiusY (double value)
{
	SetValue (EllipseGeometry::RadiusYProperty, Value (value));
}

double
EllipseGeometry::GetRadiusX ()
{
	Value *value = GetValue (EllipseGeometry::RadiusXProperty);
	return value->AsDouble ();
}

void
EllipseGeometry::SetRadiusX (double value)
{
	SetValue (EllipseGeometry::RadiusXProperty, Value (value));
}

Point *
EllipseGeometry::GetCenter ()
{
	Value *value = GetValue (EllipseGeometry::CenterProperty);
	return value ? value->AsPoint () : NULL;
}

void
EllipseGeometry::SetCenter (Point *value)
{
	if (!value) return;
	SetValue (EllipseGeometry::CenterProperty, Value (*value));
}

double
FrameworkElement::GetWidth ()
{
	Value *value = GetValue (FrameworkElement::WidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetWidth (double value)
{
	SetValue (FrameworkElement::WidthProperty, Value (value));
}

VerticalAlignment
FrameworkElement::GetVerticalAlignment ()
{
	Value *value = GetValue (FrameworkElement::VerticalAlignmentProperty);
	return (VerticalAlignment) value->AsInt32 ();
}

void
FrameworkElement::SetVerticalAlignment (VerticalAlignment value)
{
	SetValue (FrameworkElement::VerticalAlignmentProperty, Value (value));
}

Style *
FrameworkElement::GetStyle ()
{
	Value *value = GetValue (FrameworkElement::StyleProperty);
	return value ? value->AsStyle () : NULL;
}

void
FrameworkElement::SetStyle (Style *value)
{
	SetValue (FrameworkElement::StyleProperty, Value::CreateUnrefPtr (value));
}

double
FrameworkElement::GetMinWidth ()
{
	Value *value = GetValue (FrameworkElement::MinWidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMinWidth (double value)
{
	SetValue (FrameworkElement::MinWidthProperty, Value (value));
}

double
FrameworkElement::GetMinHeight ()
{
	Value *value = GetValue (FrameworkElement::MinHeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMinHeight (double value)
{
	SetValue (FrameworkElement::MinHeightProperty, Value (value));
}

double
FrameworkElement::GetMaxWidth ()
{
	Value *value = GetValue (FrameworkElement::MaxWidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMaxWidth (double value)
{
	SetValue (FrameworkElement::MaxWidthProperty, Value (value));
}

double
FrameworkElement::GetMaxHeight ()
{
	Value *value = GetValue (FrameworkElement::MaxHeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMaxHeight (double value)
{
	SetValue (FrameworkElement::MaxHeightProperty, Value (value));
}

Thickness *
FrameworkElement::GetMargin ()
{
	Value *value = GetValue (FrameworkElement::MarginProperty);
	return value ? value->AsThickness () : NULL;
}

void
FrameworkElement::SetMargin (Thickness *value)
{
	if (!value) return;
	SetValue (FrameworkElement::MarginProperty, Value (*value));
}

const char *
FrameworkElement::GetLanguage ()
{
	Value *value = GetValue (FrameworkElement::LanguageProperty);
	return value ? value->AsString () : NULL;
}

void
FrameworkElement::SetLanguage (const char *value)
{
	SetValue (FrameworkElement::LanguageProperty, Value (value));
}

HorizontalAlignment
FrameworkElement::GetHorizontalAlignment ()
{
	Value *value = GetValue (FrameworkElement::HorizontalAlignmentProperty);
	return (HorizontalAlignment) value->AsInt32 ();
}

void
FrameworkElement::SetHorizontalAlignment (HorizontalAlignment value)
{
	SetValue (FrameworkElement::HorizontalAlignmentProperty, Value (value));
}

double
FrameworkElement::GetHeight ()
{
	Value *value = GetValue (FrameworkElement::HeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetHeight (double value)
{
	SetValue (FrameworkElement::HeightProperty, Value (value));
}

double
FrameworkElement::GetActualWidth ()
{
	Value *value = GetValue (FrameworkElement::ActualWidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetActualWidth (double value)
{
	SetValue (FrameworkElement::ActualWidthProperty, Value (value));
}

double
FrameworkElement::GetActualHeight ()
{
	Value *value = GetValue (FrameworkElement::ActualHeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetActualHeight (double value)
{
	SetValue (FrameworkElement::ActualHeightProperty, Value (value));
}

double
PowerEase::GetPower ()
{
	Value *value = GetValue (PowerEase::PowerProperty);
	return value->AsDouble ();
}

void
PowerEase::SetPower (double value)
{
	SetValue (PowerEase::PowerProperty, Value (value));
}

double
ExponentialEase::GetExponent ()
{
	Value *value = GetValue (ExponentialEase::ExponentProperty);
	return value->AsDouble ();
}

void
ExponentialEase::SetExponent (double value)
{
	SetValue (ExponentialEase::ExponentProperty, Value (value));
}

double
ElasticEase::GetSpringiness ()
{
	Value *value = GetValue (ElasticEase::SpringinessProperty);
	return value->AsDouble ();
}

void
ElasticEase::SetSpringiness (double value)
{
	SetValue (ElasticEase::SpringinessProperty, Value (value));
}

gint32
ElasticEase::GetOscillations ()
{
	Value *value = GetValue (ElasticEase::OscillationsProperty);
	return value->AsInt32 ();
}

void
ElasticEase::SetOscillations (gint32 value)
{
	SetValue (ElasticEase::OscillationsProperty, Value (value));
}

double
BounceEase::GetBounciness ()
{
	Value *value = GetValue (BounceEase::BouncinessProperty);
	return value->AsDouble ();
}

void
BounceEase::SetBounciness (double value)
{
	SetValue (BounceEase::BouncinessProperty, Value (value));
}

gint32
BounceEase::GetBounces ()
{
	Value *value = GetValue (BounceEase::BouncesProperty);
	return value->AsInt32 ();
}

void
BounceEase::SetBounces (gint32 value)
{
	SetValue (BounceEase::BouncesProperty, Value (value));
}

double
BackEase::GetAmplitude ()
{
	Value *value = GetValue (BackEase::AmplitudeProperty);
	return value->AsDouble ();
}

void
BackEase::SetAmplitude (double value)
{
	SetValue (BackEase::AmplitudeProperty, Value (value));
}

KeySpline *
SplinePointKeyFrame::GetKeySpline ()
{
	Value *value = DependencyObject::GetValue (SplinePointKeyFrame::KeySplineProperty);
	return value ? value->AsKeySpline () : NULL;
}

void
SplinePointKeyFrame::SetKeySpline (KeySpline *value)
{
	DependencyObject::SetValue (SplinePointKeyFrame::KeySplineProperty, Value::CreateUnrefPtr (value));
}

EasingFunctionBase *
EasingPointKeyFrame::GetEasingFunction ()
{
	Value *value = DependencyObject::GetValue (EasingPointKeyFrame::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
EasingPointKeyFrame::SetEasingFunction (EasingFunctionBase *value)
{
	DependencyObject::SetValue (EasingPointKeyFrame::EasingFunctionProperty, Value::CreateUnrefPtr (value));
}

PointKeyFrameCollection *
PointAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (PointAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsPointKeyFrameCollection () : NULL;
}

void
PointAnimationUsingKeyFrames::SetKeyFrames (PointKeyFrameCollection *value)
{
	SetValue (PointAnimationUsingKeyFrames::KeyFramesProperty, Value::CreateUnrefPtr (value));
}

KeySpline *
SplineDoubleKeyFrame::GetKeySpline ()
{
	Value *value = DependencyObject::GetValue (SplineDoubleKeyFrame::KeySplineProperty);
	return value ? value->AsKeySpline () : NULL;
}

void
SplineDoubleKeyFrame::SetKeySpline (KeySpline *value)
{
	DependencyObject::SetValue (SplineDoubleKeyFrame::KeySplineProperty, Value::CreateUnrefPtr (value));
}

EasingFunctionBase *
EasingDoubleKeyFrame::GetEasingFunction ()
{
	Value *value = DependencyObject::GetValue (EasingDoubleKeyFrame::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
EasingDoubleKeyFrame::SetEasingFunction (EasingFunctionBase *value)
{
	DependencyObject::SetValue (EasingDoubleKeyFrame::EasingFunctionProperty, Value::CreateUnrefPtr (value));
}

DoubleKeyFrameCollection *
DoubleAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (DoubleAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsDoubleKeyFrameCollection () : NULL;
}

void
DoubleAnimationUsingKeyFrames::SetKeyFrames (DoubleKeyFrameCollection *value)
{
	SetValue (DoubleAnimationUsingKeyFrames::KeyFramesProperty, Value::CreateUnrefPtr (value));
}

const char *
TimelineMarker::GetType ()
{
	Value *value = GetValue (TimelineMarker::TypeProperty);
	return value ? value->AsString () : NULL;
}

void
TimelineMarker::SetType (const char *value)
{
	SetValue (TimelineMarker::TypeProperty, Value (value));
}

TimeSpan
TimelineMarker::GetTime ()
{
	Value *value = GetValue (TimelineMarker::TimeProperty);
	return value->AsTimeSpan ();
}

void
TimelineMarker::SetTime (TimeSpan value)
{
	SetValue (TimelineMarker::TimeProperty, Value (value, Type::TIMESPAN));
}

const char *
TimelineMarker::GetText ()
{
	Value *value = GetValue (TimelineMarker::TextProperty);
	return value ? value->AsString () : NULL;
}

void
TimelineMarker::SetText (const char *value)
{
	SetValue (TimelineMarker::TextProperty, Value (value));
}

double
Timeline::GetSpeedRatio ()
{
	Value *value = GetValue (Timeline::SpeedRatioProperty);
	return value->AsDouble ();
}

void
Timeline::SetSpeedRatio (double value)
{
	SetValue (Timeline::SpeedRatioProperty, Value (value));
}

FillBehavior
Timeline::GetFillBehavior ()
{
	Value *value = GetValue (Timeline::FillBehaviorProperty);
	return (FillBehavior) value->AsInt32 ();
}

void
Timeline::SetFillBehavior (FillBehavior value)
{
	SetValue (Timeline::FillBehaviorProperty, Value (value));
}

bool
Timeline::GetAutoReverse ()
{
	Value *value = GetValue (Timeline::AutoReverseProperty);
	return value->AsBool ();
}

void
Timeline::SetAutoReverse (bool value)
{
	SetValue (Timeline::AutoReverseProperty, Value (value));
}

double
StylusPoint::GetY ()
{
	Value *value = GetValue (StylusPoint::YProperty);
	return value->AsDouble ();
}

void
StylusPoint::SetY (double value)
{
	SetValue (StylusPoint::YProperty, Value (value));
}

double
StylusPoint::GetX ()
{
	Value *value = GetValue (StylusPoint::XProperty);
	return value->AsDouble ();
}

void
StylusPoint::SetX (double value)
{
	SetValue (StylusPoint::XProperty, Value (value));
}

double
StylusPoint::GetPressureFactor ()
{
	Value *value = GetValue (StylusPoint::PressureFactorProperty);
	return value->AsDouble ();
}

void
StylusPoint::SetPressureFactor (double value)
{
	SetValue (StylusPoint::PressureFactorProperty, Value (value));
}

bool
StylusInfo::GetIsInverted ()
{
	Value *value = GetValue (StylusInfo::IsInvertedProperty);
	return value->AsBool ();
}

void
StylusInfo::SetIsInverted (bool value)
{
	SetValue (StylusInfo::IsInvertedProperty, Value (value));
}

TabletDeviceType
StylusInfo::GetDeviceType ()
{
	Value *value = GetValue (StylusInfo::DeviceTypeProperty);
	return (TabletDeviceType) value->AsInt32 ();
}

void
StylusInfo::SetDeviceType (TabletDeviceType value)
{
	SetValue (StylusInfo::DeviceTypeProperty, Value (value));
}

SetterBaseCollection *
Style::GetSetters ()
{
	Value *value = GetValue (Style::SettersProperty);
	return value ? value->AsSetterBaseCollection () : NULL;
}

void
Style::SetSetters (SetterBaseCollection *value)
{
	SetValue (Style::SettersProperty, Value::CreateUnrefPtr (value));
}

bool
Style::GetIsSealed ()
{
	Value *value = GetValue (Style::IsSealedProperty);
	return value->AsBool ();
}

void
Style::SetIsSealed (bool value)
{
	SetValue (Style::IsSealedProperty, Value (value));
}

StylusPointCollection *
Stroke::GetStylusPoints ()
{
	Value *value = GetValue (Stroke::StylusPointsProperty);
	return value ? value->AsStylusPointCollection () : NULL;
}

void
Stroke::SetStylusPoints (StylusPointCollection *value)
{
	SetValue (Stroke::StylusPointsProperty, Value::CreateUnrefPtr (value));
}

DrawingAttributes *
Stroke::GetDrawingAttributes ()
{
	Value *value = GetValue (Stroke::DrawingAttributesProperty);
	return value ? value->AsDrawingAttributes () : NULL;
}

void
Stroke::SetDrawingAttributes (DrawingAttributes *value)
{
	SetValue (Stroke::DrawingAttributesProperty, Value::CreateUnrefPtr (value));
}

bool
SetterBase::GetIsSealed ()
{
	Value *value = GetValue (SetterBase::IsSealedProperty);
	return value->AsBool ();
}

void
SetterBase::SetIsSealed (bool value)
{
	SetValue (SetterBase::IsSealedProperty, Value (value));
}

double
RowDefinition::GetMinHeight ()
{
	Value *value = GetValue (RowDefinition::MinHeightProperty);
	return value->AsDouble ();
}

void
RowDefinition::SetMinHeight (double value)
{
	SetValue (RowDefinition::MinHeightProperty, Value (value));
}

double
RowDefinition::GetMaxHeight ()
{
	Value *value = GetValue (RowDefinition::MaxHeightProperty);
	return value->AsDouble ();
}

void
RowDefinition::SetMaxHeight (double value)
{
	SetValue (RowDefinition::MaxHeightProperty, Value (value));
}

GridLength *
RowDefinition::GetHeight ()
{
	Value *value = GetValue (RowDefinition::HeightProperty);
	return value ? value->AsGridLength () : NULL;
}

void
RowDefinition::SetHeight (GridLength *value)
{
	if (!value) return;
	SetValue (RowDefinition::HeightProperty, Value (*value));
}

double
RowDefinition::GetActualHeight ()
{
	Value *value = GetValue (RowDefinition::ActualHeightProperty);
	return value->AsDouble ();
}

void
RowDefinition::SetActualHeight (double value)
{
	SetValue (RowDefinition::ActualHeightProperty, Value (value));
}

Point *
PathFigure::GetStartPoint ()
{
	Value *value = GetValue (PathFigure::StartPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
PathFigure::SetStartPoint (Point *value)
{
	if (!value) return;
	SetValue (PathFigure::StartPointProperty, Value (*value));
}

PathSegmentCollection *
PathFigure::GetSegments ()
{
	Value *value = GetValue (PathFigure::SegmentsProperty);
	return value ? value->AsPathSegmentCollection () : NULL;
}

void
PathFigure::SetSegments (PathSegmentCollection *value)
{
	SetValue (PathFigure::SegmentsProperty, Value::CreateUnrefPtr (value));
}

bool
PathFigure::GetIsFilled ()
{
	Value *value = GetValue (PathFigure::IsFilledProperty);
	return value->AsBool ();
}

void
PathFigure::SetIsFilled (bool value)
{
	SetValue (PathFigure::IsFilledProperty, Value (value));
}

bool
PathFigure::GetIsClosed ()
{
	Value *value = GetValue (PathFigure::IsClosedProperty);
	return value->AsBool ();
}

void
PathFigure::SetIsClosed (bool value)
{
	SetValue (PathFigure::IsClosedProperty, Value (value));
}

NameScope *
NameScope::GetNameScope (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (NameScope::NameScopeProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (NameScope::NameScopeProperty)->GetDefaultValue();
	return value ? value->AsNameScope () : NULL;
}

void
NameScope::SetNameScope (DependencyObject *obj, NameScope *value)
{
	if (!obj) return;
	obj->SetValue (NameScope::NameScopeProperty, Value::CreateUnrefPtr (value));
}

gint32
MultiScaleSubImage::GetZIndex ()
{
	Value *value = GetValue (MultiScaleSubImage::ZIndexProperty);
	return value->AsInt32 ();
}

void
MultiScaleSubImage::SetZIndex (gint32 value)
{
	SetValue (MultiScaleSubImage::ZIndexProperty, Value (value));
}

double
MultiScaleSubImage::GetViewportWidth ()
{
	Value *value = GetValue (MultiScaleSubImage::ViewportWidthProperty);
	return value->AsDouble ();
}

void
MultiScaleSubImage::SetViewportWidth (double value)
{
	SetValue (MultiScaleSubImage::ViewportWidthProperty, Value (value));
}

Point *
MultiScaleSubImage::GetViewportOrigin ()
{
	Value *value = GetValue (MultiScaleSubImage::ViewportOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
MultiScaleSubImage::SetViewportOrigin (Point *value)
{
	if (!value) return;
	SetValue (MultiScaleSubImage::ViewportOriginProperty, Value (*value));
}

double
MultiScaleSubImage::GetOpacity ()
{
	Value *value = GetValue (MultiScaleSubImage::OpacityProperty);
	return value->AsDouble ();
}

void
MultiScaleSubImage::SetOpacity (double value)
{
	SetValue (MultiScaleSubImage::OpacityProperty, Value (value));
}

double
MultiScaleSubImage::GetAspectRatio ()
{
	Value *value = GetValue (MultiScaleSubImage::AspectRatioProperty);
	return value->AsDouble ();
}

const char *
MediaAttribute::GetValue ()
{
	Value *value = DependencyObject::GetValue (MediaAttribute::ValueProperty);
	return value ? value->AsString () : NULL;
}

void
MediaAttribute::SetValue (const char *value)
{
	DependencyObject::SetValue (MediaAttribute::ValueProperty, Value (value));
}

double
Matrix::GetOffsetY ()
{
	Value *value = GetValue (Matrix::OffsetYProperty);
	return value->AsDouble ();
}

void
Matrix::SetOffsetY (double value)
{
	SetValue (Matrix::OffsetYProperty, Value (value));
}

double
Matrix::GetOffsetX ()
{
	Value *value = GetValue (Matrix::OffsetXProperty);
	return value->AsDouble ();
}

void
Matrix::SetOffsetX (double value)
{
	SetValue (Matrix::OffsetXProperty, Value (value));
}

double
Matrix::GetM22 ()
{
	Value *value = GetValue (Matrix::M22Property);
	return value->AsDouble ();
}

void
Matrix::SetM22 (double value)
{
	SetValue (Matrix::M22Property, Value (value));
}

double
Matrix::GetM21 ()
{
	Value *value = GetValue (Matrix::M21Property);
	return value->AsDouble ();
}

void
Matrix::SetM21 (double value)
{
	SetValue (Matrix::M21Property, Value (value));
}

double
Matrix::GetM12 ()
{
	Value *value = GetValue (Matrix::M12Property);
	return value->AsDouble ();
}

void
Matrix::SetM12 (double value)
{
	SetValue (Matrix::M12Property, Value (value));
}

double
Matrix::GetM11 ()
{
	Value *value = GetValue (Matrix::M11Property);
	return value->AsDouble ();
}

void
Matrix::SetM11 (double value)
{
	SetValue (Matrix::M11Property, Value (value));
}

Point *
KeySpline::GetControlPoint2 ()
{
	Value *value = GetValue (KeySpline::ControlPoint2Property);
	return value ? value->AsPoint () : NULL;
}

void
KeySpline::SetControlPoint2 (Point *value)
{
	if (!value) return;
	SetValue (KeySpline::ControlPoint2Property, Value (*value));
}

Point *
KeySpline::GetControlPoint1 ()
{
	Value *value = GetValue (KeySpline::ControlPoint1Property);
	return value ? value->AsPoint () : NULL;
}

void
KeySpline::SetControlPoint1 (Point *value)
{
	if (!value) return;
	SetValue (KeySpline::ControlPoint1Property, Value (*value));
}

TextDecorations
Inline::GetTextDecorations ()
{
	Value *value = GetValue (Inline::TextDecorationsProperty);
	return (TextDecorations) value->AsInt32 ();
}

void
Inline::SetTextDecorations (TextDecorations value)
{
	SetValue (Inline::TextDecorationsProperty, Value (value));
}

const char *
Inline::GetLanguage ()
{
	Value *value = GetValue (Inline::LanguageProperty);
	return value ? value->AsString () : NULL;
}

void
Inline::SetLanguage (const char *value)
{
	SetValue (Inline::LanguageProperty, Value (value));
}

Brush *
Inline::GetForeground ()
{
	Value *value = GetValue (Inline::ForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Inline::SetForeground (Brush *value)
{
	SetValue (Inline::ForegroundProperty, Value::CreateUnrefPtr (value));
}

FontWeight *
Inline::GetFontWeight ()
{
	Value *value = GetValue (Inline::FontWeightProperty);
	return value ? value->AsFontWeight () : NULL;
}

void
Inline::SetFontWeight (FontWeight *value)
{
	if (!value) return;
	SetValue (Inline::FontWeightProperty, Value (*value));
}

FontStyle *
Inline::GetFontStyle ()
{
	Value *value = GetValue (Inline::FontStyleProperty);
	return value ? value->AsFontStyle () : NULL;
}

void
Inline::SetFontStyle (FontStyle *value)
{
	if (!value) return;
	SetValue (Inline::FontStyleProperty, Value (*value));
}

FontStretch *
Inline::GetFontStretch ()
{
	Value *value = GetValue (Inline::FontStretchProperty);
	return value ? value->AsFontStretch () : NULL;
}

void
Inline::SetFontStretch (FontStretch *value)
{
	if (!value) return;
	SetValue (Inline::FontStretchProperty, Value (*value));
}

FontSource *
Inline::GetFontSource ()
{
	Value *value = GetValue (Inline::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
Inline::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (Inline::FontSourceProperty, Value (*value));
}

double
Inline::GetFontSize ()
{
	Value *value = GetValue (Inline::FontSizeProperty);
	return value->AsDouble ();
}

void
Inline::SetFontSize (double value)
{
	SetValue (Inline::FontSizeProperty, Value (value));
}

FontFamily *
Inline::GetFontFamily ()
{
	Value *value = GetValue (Inline::FontFamilyProperty);
	return value ? value->AsFontFamily () : NULL;
}

void
Inline::SetFontFamily (FontFamily *value)
{
	if (!value) return;
	SetValue (Inline::FontFamilyProperty, Value (*value));
}

double
GradientStop::GetOffset ()
{
	Value *value = GetValue (GradientStop::OffsetProperty);
	return value->AsDouble ();
}

void
GradientStop::SetOffset (double value)
{
	SetValue (GradientStop::OffsetProperty, Value (value));
}

Color *
GradientStop::GetColor ()
{
	Value *value = GetValue (GradientStop::ColorProperty);
	return value ? value->AsColor () : NULL;
}

void
GradientStop::SetColor (Color *value)
{
	if (!value) return;
	SetValue (GradientStop::ColorProperty, Value (*value));
}

Transform *
Geometry::GetTransform ()
{
	Value *value = GetValue (Geometry::TransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
Geometry::SetTransform (Transform *value)
{
	SetValue (Geometry::TransformProperty, Value::CreateUnrefPtr (value));
}

double
DrawingAttributes::GetWidth ()
{
	Value *value = GetValue (DrawingAttributes::WidthProperty);
	return value->AsDouble ();
}

void
DrawingAttributes::SetWidth (double value)
{
	SetValue (DrawingAttributes::WidthProperty, Value (value));
}

Color *
DrawingAttributes::GetOutlineColor ()
{
	Value *value = GetValue (DrawingAttributes::OutlineColorProperty);
	return value ? value->AsColor () : NULL;
}

void
DrawingAttributes::SetOutlineColor (Color *value)
{
	if (!value) return;
	SetValue (DrawingAttributes::OutlineColorProperty, Value (*value));
}

double
DrawingAttributes::GetHeight ()
{
	Value *value = GetValue (DrawingAttributes::HeightProperty);
	return value->AsDouble ();
}

void
DrawingAttributes::SetHeight (double value)
{
	SetValue (DrawingAttributes::HeightProperty, Value (value));
}

Color *
DrawingAttributes::GetColor ()
{
	Value *value = GetValue (DrawingAttributes::ColorProperty);
	return value ? value->AsColor () : NULL;
}

void
DrawingAttributes::SetColor (Color *value)
{
	if (!value) return;
	SetValue (DrawingAttributes::ColorProperty, Value (*value));
}

Uri *
Downloader::GetUri ()
{
	Value *value = GetValue (Downloader::UriProperty);
	return value ? value->AsUri () : NULL;
}

void
Downloader::SetUri (Uri *value)
{
	if (!value) return;
	SetValue (Downloader::UriProperty, Value (*value));
}

const char *
Downloader::GetStatusText ()
{
	Value *value = GetValue (Downloader::StatusTextProperty);
	return value ? value->AsString () : NULL;
}

void
Downloader::SetStatusText (const char *value)
{
	SetValue (Downloader::StatusTextProperty, Value (value));
}

gint32
Downloader::GetStatus ()
{
	Value *value = GetValue (Downloader::StatusProperty);
	return value->AsInt32 ();
}

void
Downloader::SetStatus (gint32 value)
{
	SetValue (Downloader::StatusProperty, Value (value));
}

double
Downloader::GetDownloadProgress ()
{
	Value *value = GetValue (Downloader::DownloadProgressProperty);
	return value->AsDouble ();
}

void
Downloader::SetDownloadProgress (double value)
{
	SetValue (Downloader::DownloadProgressProperty, Value (value));
}

Surface *
Deployment::GetSurface ()
{
	Value *value = GetValue (Deployment::SurfaceProperty);
	return value ? value->AsSurface () : NULL;
}

void
Deployment::SetSurface (Surface *value)
{
	SetValue (Deployment::SurfaceProperty, Value::CreateUnrefPtr (value));
}

AssemblyPartCollection *
Deployment::GetParts ()
{
	Value *value = GetValue (Deployment::PartsProperty);
	return value ? value->AsAssemblyPartCollection () : NULL;
}

void
Deployment::SetParts (AssemblyPartCollection *value)
{
	SetValue (Deployment::PartsProperty, Value::CreateUnrefPtr (value));
}

CrossDomainAccess
Deployment::GetExternalCallersFromCrossDomain ()
{
	Value *value = GetValue (Deployment::ExternalCallersFromCrossDomainProperty);
	return (CrossDomainAccess) value->AsInt32 ();
}

void
Deployment::SetExternalCallersFromCrossDomain (CrossDomainAccess value)
{
	SetValue (Deployment::ExternalCallersFromCrossDomainProperty, Value (value));
}

GridLength *
ColumnDefinition::GetWidth ()
{
	Value *value = GetValue (ColumnDefinition::WidthProperty);
	return value ? value->AsGridLength () : NULL;
}

void
ColumnDefinition::SetWidth (GridLength *value)
{
	if (!value) return;
	SetValue (ColumnDefinition::WidthProperty, Value (*value));
}

double
ColumnDefinition::GetMinWidth ()
{
	Value *value = GetValue (ColumnDefinition::MinWidthProperty);
	return value->AsDouble ();
}

void
ColumnDefinition::SetMinWidth (double value)
{
	SetValue (ColumnDefinition::MinWidthProperty, Value (value));
}

double
ColumnDefinition::GetMaxWidth ()
{
	Value *value = GetValue (ColumnDefinition::MaxWidthProperty);
	return value->AsDouble ();
}

void
ColumnDefinition::SetMaxWidth (double value)
{
	SetValue (ColumnDefinition::MaxWidthProperty, Value (value));
}

double
ColumnDefinition::GetActualWidth ()
{
	Value *value = GetValue (ColumnDefinition::ActualWidthProperty);
	return value->AsDouble ();
}

void
ColumnDefinition::SetActualWidth (double value)
{
	SetValue (ColumnDefinition::ActualWidthProperty, Value (value));
}

gint32
Collection::GetCount ()
{
	Value *value = GetValue (Collection::CountProperty);
	return value->AsInt32 ();
}

void
Collection::SetCount (gint32 value)
{
	SetValue (Collection::CountProperty, Value (value));
}

Visibility
UIElement::GetVisibility ()
{
	Value *value = GetValue (UIElement::VisibilityProperty);
	return (Visibility) value->AsInt32 ();
}

void
UIElement::SetVisibility (Visibility value)
{
	SetValue (UIElement::VisibilityProperty, Value (value));
}

bool
UIElement::GetUseLayoutRounding ()
{
	Value *value = GetValue (UIElement::UseLayoutRoundingProperty);
	return value->AsBool ();
}

void
UIElement::SetUseLayoutRounding (bool value)
{
	SetValue (UIElement::UseLayoutRoundingProperty, Value (value));
}

TriggerCollection *
UIElement::GetTriggers ()
{
	Value *value = GetValue (UIElement::TriggersProperty);
	return value ? value->AsTriggerCollection () : NULL;
}

void
UIElement::SetTriggers (TriggerCollection *value)
{
	SetValue (UIElement::TriggersProperty, Value::CreateUnrefPtr (value));
}

ResourceDictionary *
UIElement::GetResources ()
{
	Value *value = GetValue (UIElement::ResourcesProperty);
	return value ? value->AsResourceDictionary () : NULL;
}

void
UIElement::SetResources (ResourceDictionary *value)
{
	SetValue (UIElement::ResourcesProperty, Value::CreateUnrefPtr (value));
}

Transform *
UIElement::GetRenderTransform ()
{
	Value *value = GetValue (UIElement::RenderTransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
UIElement::SetRenderTransform (Transform *value)
{
	SetValue (UIElement::RenderTransformProperty, Value::CreateUnrefPtr (value));
}

Point *
UIElement::GetRenderTransformOrigin ()
{
	Value *value = GetValue (UIElement::RenderTransformOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
UIElement::SetRenderTransformOrigin (Point *value)
{
	if (!value) return;
	SetValue (UIElement::RenderTransformOriginProperty, Value (*value));
}

double
UIElement::GetOpacity ()
{
	Value *value = GetValue (UIElement::OpacityProperty);
	return value->AsDouble ();
}

void
UIElement::SetOpacity (double value)
{
	SetValue (UIElement::OpacityProperty, Value (value));
}

Brush *
UIElement::GetOpacityMask ()
{
	Value *value = GetValue (UIElement::OpacityMaskProperty);
	return value ? value->AsBrush () : NULL;
}

void
UIElement::SetOpacityMask (Brush *value)
{
	SetValue (UIElement::OpacityMaskProperty, Value::CreateUnrefPtr (value));
}

bool
UIElement::GetIsHitTestVisible ()
{
	Value *value = GetValue (UIElement::IsHitTestVisibleProperty);
	return value->AsBool ();
}

void
UIElement::SetIsHitTestVisible (bool value)
{
	SetValue (UIElement::IsHitTestVisibleProperty, Value (value));
}

MouseCursor
UIElement::GetCursor ()
{
	Value *value = GetValue (UIElement::CursorProperty);
	return (MouseCursor) value->AsInt32 ();
}

void
UIElement::SetCursor (MouseCursor value)
{
	SetValue (UIElement::CursorProperty, Value (value));
}

Geometry *
UIElement::GetClip ()
{
	Value *value = GetValue (UIElement::ClipProperty);
	return value ? value->AsGeometry () : NULL;
}

void
UIElement::SetClip (Geometry *value)
{
	SetValue (UIElement::ClipProperty, Value::CreateUnrefPtr (value));
}

EasingMode
EasingFunctionBase::GetEasingMode ()
{
	Value *value = GetValue (EasingFunctionBase::EasingModeProperty);
	return (EasingMode) value->AsInt32 ();
}

void
EasingFunctionBase::SetEasingMode (EasingMode value)
{
	SetValue (EasingFunctionBase::EasingModeProperty, Value (value));
}

ResourceDictionary *
Application::GetResources ()
{
	Value *value = GetValue (Application::ResourcesProperty);
	return value ? value->AsResourceDictionary () : NULL;
}

void
Application::SetResources (ResourceDictionary *value)
{
	SetValue (Application::ResourcesProperty, Value::CreateUnrefPtr (value));
}

KeySpline *
SplineColorKeyFrame::GetKeySpline ()
{
	Value *value = DependencyObject::GetValue (SplineColorKeyFrame::KeySplineProperty);
	return value ? value->AsKeySpline () : NULL;
}

void
SplineColorKeyFrame::SetKeySpline (KeySpline *value)
{
	DependencyObject::SetValue (SplineColorKeyFrame::KeySplineProperty, Value::CreateUnrefPtr (value));
}

EasingFunctionBase *
EasingColorKeyFrame::GetEasingFunction ()
{
	Value *value = DependencyObject::GetValue (EasingColorKeyFrame::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
EasingColorKeyFrame::SetEasingFunction (EasingFunctionBase *value)
{
	DependencyObject::SetValue (EasingColorKeyFrame::EasingFunctionProperty, Value::CreateUnrefPtr (value));
}

ColorKeyFrameCollection *
ColorAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (ColorAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsColorKeyFrameCollection () : NULL;
}

void
ColorAnimationUsingKeyFrames::SetKeyFrames (ColorKeyFrameCollection *value)
{
	SetValue (ColorAnimationUsingKeyFrames::KeyFramesProperty, Value::CreateUnrefPtr (value));
}

Uri *
BitmapImage::GetUriSource ()
{
	Value *value = GetValue (BitmapImage::UriSourceProperty);
	return value ? value->AsUri () : NULL;
}

void
BitmapImage::SetUriSource (Uri *value)
{
	if (!value) return;
	SetValue (BitmapImage::UriSourceProperty, Value (*value));
}

double
BitmapImage::GetProgress ()
{
	Value *value = GetValue (BitmapImage::ProgressProperty);
	return value->AsDouble ();
}

void
BitmapImage::SetProgress (double value)
{
	SetValue (BitmapImage::ProgressProperty, Value (value));
}

double
TranslateTransform::GetY ()
{
	Value *value = GetValue (TranslateTransform::YProperty);
	return value->AsDouble ();
}

void
TranslateTransform::SetY (double value)
{
	SetValue (TranslateTransform::YProperty, Value (value));
}

double
TranslateTransform::GetX ()
{
	Value *value = GetValue (TranslateTransform::XProperty);
	return value->AsDouble ();
}

void
TranslateTransform::SetX (double value)
{
	SetValue (TranslateTransform::XProperty, Value (value));
}

TransformCollection *
TransformGroup::GetChildren ()
{
	Value *value = GetValue (TransformGroup::ChildrenProperty);
	return value ? value->AsTransformCollection () : NULL;
}

void
TransformGroup::SetChildren (TransformCollection *value)
{
	SetValue (TransformGroup::ChildrenProperty, Value::CreateUnrefPtr (value));
}

ScrollBarVisibility
TextBox::GetVerticalScrollBarVisibility ()
{
	Value *value = GetValue (TextBox::VerticalScrollBarVisibilityProperty);
	return (ScrollBarVisibility) value->AsInt32 ();
}

void
TextBox::SetVerticalScrollBarVisibility (ScrollBarVisibility value)
{
	SetValue (TextBox::VerticalScrollBarVisibilityProperty, Value (value));
}

TextWrapping
TextBox::GetTextWrapping ()
{
	Value *value = GetValue (TextBox::TextWrappingProperty);
	return (TextWrapping) value->AsInt32 ();
}

void
TextBox::SetTextWrapping (TextWrapping value)
{
	SetValue (TextBox::TextWrappingProperty, Value (value));
}

const char *
TextBox::GetText ()
{
	Value *value = GetValue (TextBox::TextProperty);
	return value ? value->AsString () : NULL;
}

void
TextBox::SetText (const char *value)
{
	SetValue (TextBox::TextProperty, Value (value));
}

TextAlignment
TextBox::GetTextAlignment ()
{
	Value *value = GetValue (TextBox::TextAlignmentProperty);
	return (TextAlignment) value->AsInt32 ();
}

void
TextBox::SetTextAlignment (TextAlignment value)
{
	SetValue (TextBox::TextAlignmentProperty, Value (value));
}

gint32
TextBox::GetSelectionStart ()
{
	Value *value = GetValue (TextBox::SelectionStartProperty);
	return value->AsInt32 ();
}

void
TextBox::SetSelectionStart (gint32 value)
{
	SetValue (TextBox::SelectionStartProperty, Value (value));
}

gint32
TextBox::GetSelectionLength ()
{
	Value *value = GetValue (TextBox::SelectionLengthProperty);
	return value->AsInt32 ();
}

void
TextBox::SetSelectionLength (gint32 value)
{
	SetValue (TextBox::SelectionLengthProperty, Value (value));
}

Brush *
TextBox::GetSelectionForeground ()
{
	Value *value = GetValue (TextBox::SelectionForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBox::SetSelectionForeground (Brush *value)
{
	SetValue (TextBox::SelectionForegroundProperty, Value::CreateUnrefPtr (value));
}

Brush *
TextBox::GetSelectionBackground ()
{
	Value *value = GetValue (TextBox::SelectionBackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBox::SetSelectionBackground (Brush *value)
{
	SetValue (TextBox::SelectionBackgroundProperty, Value::CreateUnrefPtr (value));
}

const char *
TextBox::GetSelectedText ()
{
	Value *value = GetValue (TextBox::SelectedTextProperty);
	return value ? value->AsString () : NULL;
}

void
TextBox::SetSelectedText (const char *value)
{
	SetValue (TextBox::SelectedTextProperty, Value (value));
}

gint32
TextBox::GetMaxLength ()
{
	Value *value = GetValue (TextBox::MaxLengthProperty);
	return value->AsInt32 ();
}

void
TextBox::SetMaxLength (gint32 value)
{
	SetValue (TextBox::MaxLengthProperty, Value (value));
}

bool
TextBox::GetIsReadOnly ()
{
	Value *value = GetValue (TextBox::IsReadOnlyProperty);
	return value->AsBool ();
}

void
TextBox::SetIsReadOnly (bool value)
{
	SetValue (TextBox::IsReadOnlyProperty, Value (value));
}

ScrollBarVisibility
TextBox::GetHorizontalScrollBarVisibility ()
{
	Value *value = GetValue (TextBox::HorizontalScrollBarVisibilityProperty);
	return (ScrollBarVisibility) value->AsInt32 ();
}

void
TextBox::SetHorizontalScrollBarVisibility (ScrollBarVisibility value)
{
	SetValue (TextBox::HorizontalScrollBarVisibilityProperty, Value (value));
}

FontSource *
TextBox::GetFontSource ()
{
	Value *value = GetValue (TextBox::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
TextBox::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (TextBox::FontSourceProperty, Value (*value));
}

Brush *
TextBox::GetCaretBrush ()
{
	Value *value = GetValue (TextBox::CaretBrushProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBox::SetCaretBrush (Brush *value)
{
	SetValue (TextBox::CaretBrushProperty, Value::CreateUnrefPtr (value));
}

bool
TextBox::GetAcceptsReturn ()
{
	Value *value = GetValue (TextBox::AcceptsReturnProperty);
	return value->AsBool ();
}

void
TextBox::SetAcceptsReturn (bool value)
{
	SetValue (TextBox::AcceptsReturnProperty, Value (value));
}

PropertyPath *
Storyboard::GetTargetProperty (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Storyboard::TargetPropertyProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Storyboard::TargetPropertyProperty)->GetDefaultValue();
	return value ? value->AsPropertyPath () : NULL;
}

void
Storyboard::SetTargetProperty (DependencyObject *obj, PropertyPath *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (Storyboard::TargetPropertyProperty, Value (*value));
}

const char *
Storyboard::GetTargetName (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Storyboard::TargetNameProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Storyboard::TargetNameProperty)->GetDefaultValue();
	return value ? value->AsString () : NULL;
}

void
Storyboard::SetTargetName (DependencyObject *obj, const char *value)
{
	if (!obj) return;
	obj->SetValue (Storyboard::TargetNameProperty, Value (value));
}

double
SkewTransform::GetCenterY ()
{
	Value *value = GetValue (SkewTransform::CenterYProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetCenterY (double value)
{
	SetValue (SkewTransform::CenterYProperty, Value (value));
}

double
SkewTransform::GetCenterX ()
{
	Value *value = GetValue (SkewTransform::CenterXProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetCenterX (double value)
{
	SetValue (SkewTransform::CenterXProperty, Value (value));
}

double
SkewTransform::GetAngleY ()
{
	Value *value = GetValue (SkewTransform::AngleYProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetAngleY (double value)
{
	SetValue (SkewTransform::AngleYProperty, Value (value));
}

double
SkewTransform::GetAngleX ()
{
	Value *value = GetValue (SkewTransform::AngleXProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetAngleX (double value)
{
	SetValue (SkewTransform::AngleXProperty, Value (value));
}

bool
SetterBaseCollection::GetIsSealed ()
{
	Value *value = GetValue (SetterBaseCollection::IsSealedProperty);
	return value->AsBool ();
}

void
SetterBaseCollection::SetIsSealed (bool value)
{
	SetValue (SetterBaseCollection::IsSealedProperty, Value (value));
}

double
ScaleTransform::GetScaleY ()
{
	Value *value = GetValue (ScaleTransform::ScaleYProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetScaleY (double value)
{
	SetValue (ScaleTransform::ScaleYProperty, Value (value));
}

double
ScaleTransform::GetScaleX ()
{
	Value *value = GetValue (ScaleTransform::ScaleXProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetScaleX (double value)
{
	SetValue (ScaleTransform::ScaleXProperty, Value (value));
}

double
ScaleTransform::GetCenterY ()
{
	Value *value = GetValue (ScaleTransform::CenterYProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetCenterY (double value)
{
	SetValue (ScaleTransform::CenterYProperty, Value (value));
}

double
ScaleTransform::GetCenterX ()
{
	Value *value = GetValue (ScaleTransform::CenterXProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetCenterX (double value)
{
	SetValue (ScaleTransform::CenterXProperty, Value (value));
}

double
RotateTransform::GetCenterY ()
{
	Value *value = GetValue (RotateTransform::CenterYProperty);
	return value->AsDouble ();
}

void
RotateTransform::SetCenterY (double value)
{
	SetValue (RotateTransform::CenterYProperty, Value (value));
}

double
RotateTransform::GetCenterX ()
{
	Value *value = GetValue (RotateTransform::CenterXProperty);
	return value->AsDouble ();
}

void
RotateTransform::SetCenterX (double value)
{
	SetValue (RotateTransform::CenterXProperty, Value (value));
}

double
RotateTransform::GetAngle ()
{
	Value *value = GetValue (RotateTransform::AngleProperty);
	return value->AsDouble ();
}

void
RotateTransform::SetAngle (double value)
{
	SetValue (RotateTransform::AngleProperty, Value (value));
}

Point *
QuadraticBezierSegment::GetPoint2 ()
{
	Value *value = GetValue (QuadraticBezierSegment::Point2Property);
	return value ? value->AsPoint () : NULL;
}

void
QuadraticBezierSegment::SetPoint2 (Point *value)
{
	if (!value) return;
	SetValue (QuadraticBezierSegment::Point2Property, Value (*value));
}

Point *
QuadraticBezierSegment::GetPoint1 ()
{
	Value *value = GetValue (QuadraticBezierSegment::Point1Property);
	return value ? value->AsPoint () : NULL;
}

void
QuadraticBezierSegment::SetPoint1 (Point *value)
{
	if (!value) return;
	SetValue (QuadraticBezierSegment::Point1Property, Value (*value));
}

PointCollection *
PolyQuadraticBezierSegment::GetPoints ()
{
	Value *value = GetValue (PolyQuadraticBezierSegment::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
PolyQuadraticBezierSegment::SetPoints (PointCollection *value)
{
	SetValue (PolyQuadraticBezierSegment::PointsProperty, Value::CreateUnrefPtr (value));
}

PointCollection *
PolyLineSegment::GetPoints ()
{
	Value *value = GetValue (PolyLineSegment::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
PolyLineSegment::SetPoints (PointCollection *value)
{
	SetValue (PolyLineSegment::PointsProperty, Value::CreateUnrefPtr (value));
}

PointCollection *
PolyBezierSegment::GetPoints ()
{
	Value *value = GetValue (PolyBezierSegment::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
PolyBezierSegment::SetPoints (PointCollection *value)
{
	SetValue (PolyBezierSegment::PointsProperty, Value::CreateUnrefPtr (value));
}

Point *
PointKeyFrame::GetValue ()
{
	Value *value = DependencyObject::GetValue (PointKeyFrame::ValueProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointKeyFrame::SetValue (Point value)
{
	DependencyObject::SetValue (PointKeyFrame::ValueProperty, Value (value));
}

void
PointKeyFrame::SetValue (Point *value)
{
	if (!value)
		DependencyObject::SetValue (PointKeyFrame::ValueProperty, NULL);
	else
		DependencyObject::SetValue (PointKeyFrame::ValueProperty, Value (*value));
}

KeyTime *
PointKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (PointKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
PointKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (PointKeyFrame::KeyTimeProperty, Value (value));
}

void
PointKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (PointKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (PointKeyFrame::KeyTimeProperty, Value (*value));
}

Point *
PointAnimation::GetTo ()
{
	Value *value = GetValue (PointAnimation::ToProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointAnimation::SetTo (Point value)
{
	SetValue (PointAnimation::ToProperty, Value (value));
}

void
PointAnimation::SetTo (Point *value)
{
	if (!value)
		SetValue (PointAnimation::ToProperty, NULL);
	else
		SetValue (PointAnimation::ToProperty, Value (*value));
}

Point *
PointAnimation::GetFrom ()
{
	Value *value = GetValue (PointAnimation::FromProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointAnimation::SetFrom (Point value)
{
	SetValue (PointAnimation::FromProperty, Value (value));
}

void
PointAnimation::SetFrom (Point *value)
{
	if (!value)
		SetValue (PointAnimation::FromProperty, NULL);
	else
		SetValue (PointAnimation::FromProperty, Value (*value));
}

EasingFunctionBase *
PointAnimation::GetEasingFunction ()
{
	Value *value = GetValue (PointAnimation::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
PointAnimation::SetEasingFunction (EasingFunctionBase *value)
{
	SetValue (PointAnimation::EasingFunctionProperty, Value::CreateUnrefPtr (value));
}

Point *
PointAnimation::GetBy ()
{
	Value *value = GetValue (PointAnimation::ByProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointAnimation::SetBy (Point value)
{
	SetValue (PointAnimation::ByProperty, Value (value));
}

void
PointAnimation::SetBy (Point *value)
{
	if (!value)
		SetValue (PointAnimation::ByProperty, NULL);
	else
		SetValue (PointAnimation::ByProperty, Value (*value));
}

gint32
PasswordBox::GetSelectionStart ()
{
	Value *value = GetValue (PasswordBox::SelectionStartProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetSelectionStart (gint32 value)
{
	SetValue (PasswordBox::SelectionStartProperty, Value (value));
}

gint32
PasswordBox::GetSelectionLength ()
{
	Value *value = GetValue (PasswordBox::SelectionLengthProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetSelectionLength (gint32 value)
{
	SetValue (PasswordBox::SelectionLengthProperty, Value (value));
}

Brush *
PasswordBox::GetSelectionForeground ()
{
	Value *value = GetValue (PasswordBox::SelectionForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
PasswordBox::SetSelectionForeground (Brush *value)
{
	SetValue (PasswordBox::SelectionForegroundProperty, Value::CreateUnrefPtr (value));
}

Brush *
PasswordBox::GetSelectionBackground ()
{
	Value *value = GetValue (PasswordBox::SelectionBackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
PasswordBox::SetSelectionBackground (Brush *value)
{
	SetValue (PasswordBox::SelectionBackgroundProperty, Value::CreateUnrefPtr (value));
}

const char *
PasswordBox::GetSelectedText ()
{
	Value *value = GetValue (PasswordBox::SelectedTextProperty);
	return value ? value->AsString () : NULL;
}

void
PasswordBox::SetSelectedText (const char *value)
{
	SetValue (PasswordBox::SelectedTextProperty, Value (value));
}

const char *
PasswordBox::GetPassword ()
{
	Value *value = GetValue (PasswordBox::PasswordProperty);
	return value ? value->AsString () : NULL;
}

void
PasswordBox::SetPassword (const char *value)
{
	SetValue (PasswordBox::PasswordProperty, Value (value));
}

gunichar
PasswordBox::GetPasswordChar ()
{
	Value *value = GetValue (PasswordBox::PasswordCharProperty);
	return value->AsChar ();
}

void
PasswordBox::SetPasswordChar (gunichar value)
{
	SetValue (PasswordBox::PasswordCharProperty, Value (value, Type::CHAR));
}

gint32
PasswordBox::GetMaxLength ()
{
	Value *value = GetValue (PasswordBox::MaxLengthProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetMaxLength (gint32 value)
{
	SetValue (PasswordBox::MaxLengthProperty, Value (value));
}

FontSource *
PasswordBox::GetFontSource ()
{
	Value *value = GetValue (PasswordBox::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
PasswordBox::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (PasswordBox::FontSourceProperty, Value (*value));
}

Brush *
PasswordBox::GetCaretBrush ()
{
	Value *value = GetValue (PasswordBox::CaretBrushProperty);
	return value ? value->AsBrush () : NULL;
}

void
PasswordBox::SetCaretBrush (Brush *value)
{
	SetValue (PasswordBox::CaretBrushProperty, Value::CreateUnrefPtr (value));
}

KeyTime *
ObjectKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (ObjectKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
ObjectKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (ObjectKeyFrame::KeyTimeProperty, Value (value));
}

void
ObjectKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (ObjectKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (ObjectKeyFrame::KeyTimeProperty, Value (*value));
}

Value *
ObjectKeyFrame::GetConvertedValue ()
{
	return DependencyObject::GetValue (ObjectKeyFrame::ConvertedValueProperty);
}

void
ObjectKeyFrame::SetConvertedValue (Value * value)
{
	DependencyObject::SetValue (ObjectKeyFrame::ConvertedValueProperty, Value (*value));
}

ObjectKeyFrameCollection *
ObjectAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (ObjectAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsObjectKeyFrameCollection () : NULL;
}

void
ObjectAnimationUsingKeyFrames::SetKeyFrames (ObjectKeyFrameCollection *value)
{
	SetValue (ObjectAnimationUsingKeyFrames::KeyFramesProperty, Value::CreateUnrefPtr (value));
}

Matrix *
MatrixTransform::GetMatrix ()
{
	Value *value = GetValue (MatrixTransform::MatrixProperty);
	return value ? value->AsMatrix () : NULL;
}

void
MatrixTransform::SetMatrix (Matrix *value)
{
	SetValue (MatrixTransform::MatrixProperty, Value::CreateUnrefPtr (value));
}

Point *
LineSegment::GetPoint ()
{
	Value *value = GetValue (LineSegment::PointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LineSegment::SetPoint (Point *value)
{
	if (!value) return;
	SetValue (LineSegment::PointProperty, Value (*value));
}

Rect *
LayoutInformation::GetLayoutSlot (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LayoutSlotProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LayoutSlotProperty)->GetDefaultValue();
	return value ? value->AsRect () : NULL;
}

void
LayoutInformation::SetLayoutSlot (DependencyObject *obj, Rect *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LayoutSlotProperty, Value (*value));
}

Geometry *
LayoutInformation::GetLayoutClip (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LayoutClipProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LayoutClipProperty)->GetDefaultValue();
	return value ? value->AsGeometry () : NULL;
}

void
LayoutInformation::SetLayoutClip (DependencyObject *obj, Geometry *value)
{
	if (!obj) return;
	obj->SetValue (LayoutInformation::LayoutClipProperty, Value::CreateUnrefPtr (value));
}

Size *
LayoutInformation::GetLastRenderSize (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LastRenderSizeProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LastRenderSizeProperty)->GetDefaultValue();
	return value ? value->AsSize () : NULL;
}

void
LayoutInformation::SetLastRenderSize (DependencyObject *obj, Size *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LastRenderSizeProperty, Value (*value));
}

Size *
LayoutInformation::GetLastMeasure (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LastMeasureProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LastMeasureProperty)->GetDefaultValue();
	return value ? value->AsSize () : NULL;
}

void
LayoutInformation::SetLastMeasure (DependencyObject *obj, Size *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LastMeasureProperty, Value (*value));
}

Size *
LayoutInformation::GetLastArrange (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LastArrangeProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LastArrangeProperty)->GetDefaultValue();
	return value ? value->AsSize () : NULL;
}

void
LayoutInformation::SetLastArrange (DependencyObject *obj, Size *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LastArrangeProperty, Value (*value));
}

const char *
EventTrigger::GetRoutedEvent ()
{
	Value *value = GetValue (EventTrigger::RoutedEventProperty);
	return value ? value->AsString () : NULL;
}

void
EventTrigger::SetRoutedEvent (const char *value)
{
	SetValue (EventTrigger::RoutedEventProperty, Value (value));
}

TriggerActionCollection *
EventTrigger::GetActions ()
{
	Value *value = GetValue (EventTrigger::ActionsProperty);
	return value ? value->AsTriggerActionCollection () : NULL;
}

void
EventTrigger::SetActions (TriggerActionCollection *value)
{
	SetValue (EventTrigger::ActionsProperty, Value::CreateUnrefPtr (value));
}

double *
DoubleKeyFrame::GetValue ()
{
	Value *value = DependencyObject::GetValue (DoubleKeyFrame::ValueProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleKeyFrame::SetValue (double value)
{
	DependencyObject::SetValue (DoubleKeyFrame::ValueProperty, Value (value));
}

void
DoubleKeyFrame::SetValue (double * value)
{
	if (!value)
		DependencyObject::SetValue (DoubleKeyFrame::ValueProperty, NULL);
	else
		DependencyObject::SetValue (DoubleKeyFrame::ValueProperty, Value (*value));
}

KeyTime *
DoubleKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (DoubleKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
DoubleKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (DoubleKeyFrame::KeyTimeProperty, Value (value));
}

void
DoubleKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (DoubleKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (DoubleKeyFrame::KeyTimeProperty, Value (*value));
}

double *
DoubleAnimation::GetTo ()
{
	Value *value = GetValue (DoubleAnimation::ToProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleAnimation::SetTo (double value)
{
	SetValue (DoubleAnimation::ToProperty, Value (value));
}

void
DoubleAnimation::SetTo (double * value)
{
	if (!value)
		SetValue (DoubleAnimation::ToProperty, NULL);
	else
		SetValue (DoubleAnimation::ToProperty, Value (*value));
}

double *
DoubleAnimation::GetFrom ()
{
	Value *value = GetValue (DoubleAnimation::FromProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleAnimation::SetFrom (double value)
{
	SetValue (DoubleAnimation::FromProperty, Value (value));
}

void
DoubleAnimation::SetFrom (double * value)
{
	if (!value)
		SetValue (DoubleAnimation::FromProperty, NULL);
	else
		SetValue (DoubleAnimation::FromProperty, Value (*value));
}

EasingFunctionBase *
DoubleAnimation::GetEasingFunction ()
{
	Value *value = GetValue (DoubleAnimation::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
DoubleAnimation::SetEasingFunction (EasingFunctionBase *value)
{
	SetValue (DoubleAnimation::EasingFunctionProperty, Value::CreateUnrefPtr (value));
}

double *
DoubleAnimation::GetBy ()
{
	Value *value = GetValue (DoubleAnimation::ByProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleAnimation::SetBy (double value)
{
	SetValue (DoubleAnimation::ByProperty, Value (value));
}

void
DoubleAnimation::SetBy (double * value)
{
	if (!value)
		SetValue (DoubleAnimation::ByProperty, NULL);
	else
		SetValue (DoubleAnimation::ByProperty, Value (*value));
}

const char *
DependencyObject::GetName ()
{
	Value *value = GetValue (DependencyObject::NameProperty);
	return value ? value->AsString () : NULL;
}

void
DependencyObject::SetName (const char *value)
{
	SetValue (DependencyObject::NameProperty, Value (value));
}

Uri *
DeepZoomImageTileSource::GetUriSource ()
{
	Value *value = GetValue (DeepZoomImageTileSource::UriSourceProperty);
	return value ? value->AsUri () : NULL;
}

void
DeepZoomImageTileSource::SetUriSource (Uri *value)
{
	if (!value) return;
	SetValue (DeepZoomImageTileSource::UriSourceProperty, Value (*value));
}

Color *
ColorKeyFrame::GetValue ()
{
	Value *value = DependencyObject::GetValue (ColorKeyFrame::ValueProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorKeyFrame::SetValue (Color value)
{
	DependencyObject::SetValue (ColorKeyFrame::ValueProperty, Value (value));
}

void
ColorKeyFrame::SetValue (Color *value)
{
	if (!value)
		DependencyObject::SetValue (ColorKeyFrame::ValueProperty, NULL);
	else
		DependencyObject::SetValue (ColorKeyFrame::ValueProperty, Value (*value));
}

KeyTime *
ColorKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (ColorKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
ColorKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (ColorKeyFrame::KeyTimeProperty, Value (value));
}

void
ColorKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (ColorKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (ColorKeyFrame::KeyTimeProperty, Value (*value));
}

Color *
ColorAnimation::GetTo ()
{
	Value *value = GetValue (ColorAnimation::ToProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorAnimation::SetTo (Color value)
{
	SetValue (ColorAnimation::ToProperty, Value (value));
}

void
ColorAnimation::SetTo (Color *value)
{
	if (!value)
		SetValue (ColorAnimation::ToProperty, NULL);
	else
		SetValue (ColorAnimation::ToProperty, Value (*value));
}

Color *
ColorAnimation::GetFrom ()
{
	Value *value = GetValue (ColorAnimation::FromProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorAnimation::SetFrom (Color value)
{
	SetValue (ColorAnimation::FromProperty, Value (value));
}

void
ColorAnimation::SetFrom (Color *value)
{
	if (!value)
		SetValue (ColorAnimation::FromProperty, NULL);
	else
		SetValue (ColorAnimation::FromProperty, Value (*value));
}

EasingFunctionBase *
ColorAnimation::GetEasingFunction ()
{
	Value *value = GetValue (ColorAnimation::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
ColorAnimation::SetEasingFunction (EasingFunctionBase *value)
{
	SetValue (ColorAnimation::EasingFunctionProperty, Value::CreateUnrefPtr (value));
}

Color *
ColorAnimation::GetBy ()
{
	Value *value = GetValue (ColorAnimation::ByProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorAnimation::SetBy (Color value)
{
	SetValue (ColorAnimation::ByProperty, Value (value));
}

void
ColorAnimation::SetBy (Color *value)
{
	if (!value)
		SetValue (ColorAnimation::ByProperty, NULL);
	else
		SetValue (ColorAnimation::ByProperty, Value (*value));
}

gint32
BitmapSource::GetPixelWidth ()
{
	Value *value = GetValue (BitmapSource::PixelWidthProperty);
	return value->AsInt32 ();
}

void
BitmapSource::SetPixelWidth (gint32 value)
{
	SetValue (BitmapSource::PixelWidthProperty, Value (value));
}

gint32
BitmapSource::GetPixelHeight ()
{
	Value *value = GetValue (BitmapSource::PixelHeightProperty);
	return value->AsInt32 ();
}

void
BitmapSource::SetPixelHeight (gint32 value)
{
	SetValue (BitmapSource::PixelHeightProperty, Value (value));
}

PixelFormats
BitmapSource::GetPixelFormat ()
{
	Value *value = GetValue (BitmapSource::PixelFormatProperty);
	return (PixelFormats) value->AsInt32 ();
}

void
BitmapSource::SetPixelFormat (PixelFormats value)
{
	SetValue (BitmapSource::PixelFormatProperty, Value (value));
}

Point *
BezierSegment::GetPoint3 ()
{
	Value *value = GetValue (BezierSegment::Point3Property);
	return value ? value->AsPoint () : NULL;
}

void
BezierSegment::SetPoint3 (Point *value)
{
	if (!value) return;
	SetValue (BezierSegment::Point3Property, Value (*value));
}

Point *
BezierSegment::GetPoint2 ()
{
	Value *value = GetValue (BezierSegment::Point2Property);
	return value ? value->AsPoint () : NULL;
}

void
BezierSegment::SetPoint2 (Point *value)
{
	if (!value) return;
	SetValue (BezierSegment::Point2Property, Value (*value));
}

Point *
BezierSegment::GetPoint1 ()
{
	Value *value = GetValue (BezierSegment::Point1Property);
	return value ? value->AsPoint () : NULL;
}

void
BezierSegment::SetPoint1 (Point *value)
{
	if (!value) return;
	SetValue (BezierSegment::Point1Property, Value (*value));
}

Storyboard *
BeginStoryboard::GetStoryboard ()
{
	Value *value = GetValue (BeginStoryboard::StoryboardProperty);
	return value ? value->AsStoryboard () : NULL;
}

void
BeginStoryboard::SetStoryboard (Storyboard *value)
{
	SetValue (BeginStoryboard::StoryboardProperty, Value::CreateUnrefPtr (value));
}

SweepDirection
ArcSegment::GetSweepDirection ()
{
	Value *value = GetValue (ArcSegment::SweepDirectionProperty);
	return (SweepDirection) value->AsInt32 ();
}

void
ArcSegment::SetSweepDirection (SweepDirection value)
{
	SetValue (ArcSegment::SweepDirectionProperty, Value (value));
}

Size *
ArcSegment::GetSize ()
{
	Value *value = GetValue (ArcSegment::SizeProperty);
	return value ? value->AsSize () : NULL;
}

void
ArcSegment::SetSize (Size *value)
{
	if (!value) return;
	SetValue (ArcSegment::SizeProperty, Value (*value));
}

double
ArcSegment::GetRotationAngle ()
{
	Value *value = GetValue (ArcSegment::RotationAngleProperty);
	return value->AsDouble ();
}

void
ArcSegment::SetRotationAngle (double value)
{
	SetValue (ArcSegment::RotationAngleProperty, Value (value));
}

Point *
ArcSegment::GetPoint ()
{
	Value *value = GetValue (ArcSegment::PointProperty);
	return value ? value->AsPoint () : NULL;
}

void
ArcSegment::SetPoint (Point *value)
{
	if (!value) return;
	SetValue (ArcSegment::PointProperty, Value (*value));
}

bool
ArcSegment::GetIsLargeArc ()
{
	Value *value = GetValue (ArcSegment::IsLargeArcProperty);
	return value->AsBool ();
}

void
ArcSegment::SetIsLargeArc (bool value)
{
	SetValue (ArcSegment::IsLargeArcProperty, Value (value));
}

