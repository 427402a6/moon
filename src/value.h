/*
 * Automatically generated from value.h.in, do not edit this file directly
 * To regenerate execute typegen.sh
*/
#ifndef MOON_VALUE_H
#define MOON_VALUE_H

/* ugly file containing the catchall value type we use.
   implementation still lives in runtime.cpp
*/

struct Color;
struct DoubleArray;
struct Duration;
struct KeyTime;
struct Point;
struct PointArray;
struct Rect;
struct RepeatBehavior;
struct Value;

typedef cairo_matrix_t Matrix;

class Type;
class DependencyProperty;
class Surface;

class DependencyObject;
class Animation;
class AnimationClock;
class ArcSegment;
class BeginStoryboard;
class BezierSegment;
class Brush;
class Canvas;
class Clock;
class ClockGroup;
class Collection;
class ColorAnimation;
class ColorAnimationUsingKeyFrames;
class ColorKeyFrame;
class DiscreteColorKeyFrame;
class DiscreteDoubleKeyFrame;
class DiscretePointKeyFrame;
class DoubleAnimation;
class DoubleAnimationUsingKeyFrames;
class DoubleKeyFrame;
class Downloader;
class Ellipse;
class EllipseGeometry;
class EventTrigger;
class FrameworkElement;
class Geometry;
class GeometryCollection;
class GeometryGroup;
class Glyphs;
class GradientBrush;
class GradientStop;
class GradientStopCollection;
class ImageBrush;
class Inline;
class Inlines;
class KeyFrame;
class KeyFrameCollection;
class Line;
class LinearColorKeyFrame;
class LinearDoubleKeyFrame;
class LinearGradientBrush;
class LinearPointKeyFrame;
class LineGeometry;
class LineSegment;
class MatrixTransform;
class MediaAttribute;
class MediaAttributeCollection;
class MediaBase;
class MediaElement;
class NameScope;
class Panel;
class ParallelTimeline;
class Path;
class PathFigure;
class PathFigureCollection;
class PathGeometry;
class PathSegment;
class PathSegmentCollection;
class PointAnimation;
class PointAnimationUsingKeyFrames;
class PointKeyFrame;
class PolyBezierSegment;
class Polygon;
class Polyline;
class PolyLineSegment;
class PolyQuadraticBezierSegment;
class QuadraticBezierSegment;
class RadialGradientBrush;
class Rectangle;
class RectangleGeometry;
class ResourceCollection;
class RotateTransform;
class ScaleTransform;
class Shape;
class SkewTransform;
class SolidColorBrush;
class Storyboard;
class StrokeCollection;
class StylusPointCollection;
class TextBlock;
class TileBrush;
class Timeline;
class TimelineCollection;
class TimelineGroup;
class TimelineMarkerCollection;
class Transform;
class TransformCollection;
class TransformGroup;
class TranslateTransform;
class TriggerAction;
class TriggerActionCollection;
class TriggerCollection;
class UIElement;
class VideoBrush;
class Visual;
class VisualCollection;


#define checked_get_exact(kind, errval, mem)  g_return_val_if_fail (k == (kind), errval); return mem;
#define checked_get_subclass(kind, castas)  g_return_val_if_fail (Type::Find((kind))->IsSubclassOf(k) || Type::Find(k)->IsSubclassOf((kind)), NULL); return (castas*)u.dependency_object;

struct Value {
public:
	enum Kind {
// START_MANAGED_MAPPING
		INVALID,
		BOOL,
		DOUBLE,
		UINT64,
		INT32,
		STRING,
		COLOR,
		POINT,
		RECT,
		REPEATBEHAVIOR,
		DURATION,
		INT64,
		DOUBLE_ARRAY,
		POINT_ARRAY,
		KEYTIME,
		MATRIX,

		DEPENDENCY_OBJECT,
		ANIMATION,
		ANIMATIONCLOCK,
		ARCSEGMENT,
		BEGINSTORYBOARD,
		BEZIERSEGMENT,
		BRUSH,
		CANVAS,
		CLOCK,
		CLOCKGROUP,
		COLLECTION,
		COLORANIMATION,
		COLORANIMATIONUSINGKEYFRAMES,
		COLORKEYFRAME,
		DISCRETECOLORKEYFRAME,
		DISCRETEDOUBLEKEYFRAME,
		DISCRETEPOINTKEYFRAME,
		DOUBLEANIMATION,
		DOUBLEANIMATIONUSINGKEYFRAMES,
		DOUBLEKEYFRAME,
		DOWNLOADER,
		ELLIPSE,
		ELLIPSEGEOMETRY,
		EVENTTRIGGER,
		FRAMEWORKELEMENT,
		GEOMETRY,
		GEOMETRY_COLLECTION,
		GEOMETRYGROUP,
		GLYPHS,
		GRADIENTBRUSH,
		GRADIENTSTOP,
		GRADIENTSTOP_COLLECTION,
		IMAGEBRUSH,
		INLINE,
		INLINES,
		KEYFRAME,
		KEYFRAME_COLLECTION,
		LINE,
		LINEARCOLORKEYFRAME,
		LINEARDOUBLEKEYFRAME,
		LINEARGRADIENTBRUSH,
		LINEARPOINTKEYFRAME,
		LINEGEOMETRY,
		LINESEGMENT,
		MATRIXTRANSFORM,
		MEDIAATTRIBUTE,
		MEDIAATTRIBUTE_COLLECTION,
		MEDIABASE,
		MEDIAELEMENT,
		NAMESCOPE,
		PANEL,
		PARALLELTIMELINE,
		PATH,
		PATHFIGURE,
		PATHFIGURE_COLLECTION,
		PATHGEOMETRY,
		PATHSEGMENT,
		PATHSEGMENT_COLLECTION,
		POINTANIMATION,
		POINTANIMATIONUSINGKEYFRAMES,
		POINTKEYFRAME,
		POLYBEZIERSEGMENT,
		POLYGON,
		POLYLINE,
		POLYLINESEGMENT,
		POLYQUADRATICBEZIERSEGMENT,
		QUADRATICBEZIERSEGMENT,
		RADIALGRADIENTBRUSH,
		RECTANGLE,
		RECTANGLEGEOMETRY,
		RESOURCE_COLLECTION,
		ROTATETRANSFORM,
		SCALETRANSFORM,
		SHAPE,
		SKEWTRANSFORM,
		SOLIDCOLORBRUSH,
		STORYBOARD,
		STROKE_COLLECTION,
		STYLUSPOINT_COLLECTION,
		TEXTBLOCK,
		TILEBRUSH,
		TIMELINE,
		TIMELINE_COLLECTION,
		TIMELINEGROUP,
		TIMELINEMARKER_COLLECTION,
		TRANSFORM,
		TRANSFORM_COLLECTION,
		TRANSFORMGROUP,
		TRANSLATETRANSFORM,
		TRIGGERACTION,
		TRIGGERACTION_COLLECTION,
		TRIGGER_COLLECTION,
		UIELEMENT,
		VIDEOBRUSH,
		VISUAL,
		VISUAL_COLLECTION,


		LASTTYPE
// END_MANAGED_MAPPING
	};

	void Init ();

	Value ();
	Value (const Value& v);
	Value (Kind k);
	Value (bool z);
	Value (double d);
	Value (guint64 i);
	Value (gint64 i);
	Value (gint32 i);
	Value (Color c);
	Value (DependencyObject *obj);
	Value (Point pt);
	Value (Rect rect);
	Value (RepeatBehavior repeat);
	Value (Duration duration);
	Value (KeyTime keytime);
	Value (const char* s);
	Value (Point *points, int count);
	Value (double *values, int count);
	Value (Matrix* matrix);
	
	~Value ();

	bool operator!= (const Value &v) const
	{
		return !(*this == v);
	}

	bool operator== (const Value &v) const
	{
		if (k != v.k)
			return false;

		if (k == STRING) {
			return !strcmp (u.s, v.u.s);
		}
		else {
			return !memcmp (&u, &v.u, sizeof (u));
		}

		return true;
	}

	bool            AsBool ();
	double          AsDouble ();
	guint64         AsUint64 ();
	gint64          AsInt64 ();
	gint32          AsInt32 ();

	double*         AsNullableDouble ();
	guint64*        AsNullableUint64 ();
	gint64*         AsNullableInt64 ();
	gint32*         AsNullableInt32 ();

	Color*          AsColor ();
	Point*          AsPoint ();
	Rect*           AsRect  ();
	char*           AsString ();
	RepeatBehavior* AsRepeatBehavior ();
	Duration*       AsDuration ();
	KeyTime*        AsKeyTime ();
	PointArray*     AsPointArray ();
	DoubleArray*    AsDoubleArray ();
	Matrix*		AsMatrix ();

	DependencyObject*              AsDependencyObject ();
	Animation*                     AsAnimation ();
	AnimationClock*                AsAnimationClock ();
	ArcSegment*                    AsArcSegment ();
	BeginStoryboard*               AsBeginStoryboard ();
	BezierSegment*                 AsBezierSegment ();
	Brush*                         AsBrush ();
	Canvas*                        AsCanvas ();
	Clock*                         AsClock ();
	ClockGroup*                    AsClockGroup ();
	Collection*                    AsCollection ();
	ColorAnimation*                AsColorAnimation ();
	ColorAnimationUsingKeyFrames*  AsColorAnimationUsingKeyFrames ();
	ColorKeyFrame*                 AsColorKeyFrame ();
	DiscreteColorKeyFrame*         AsDiscreteColorKeyFrame ();
	DiscreteDoubleKeyFrame*        AsDiscreteDoubleKeyFrame ();
	DiscretePointKeyFrame*         AsDiscretePointKeyFrame ();
	DoubleAnimation*               AsDoubleAnimation ();
	DoubleAnimationUsingKeyFrames* AsDoubleAnimationUsingKeyFrames ();
	DoubleKeyFrame*                AsDoubleKeyFrame ();
	Downloader*                    AsDownloader ();
	Ellipse*                       AsEllipse ();
	EllipseGeometry*               AsEllipseGeometry ();
	EventTrigger*                  AsEventTrigger ();
	FrameworkElement*              AsFrameworkElement ();
	Geometry*                      AsGeometry ();
	GeometryCollection*            AsGeometryCollection ();
	GeometryGroup*                 AsGeometryGroup ();
	Glyphs*                        AsGlyphs ();
	GradientBrush*                 AsGradientBrush ();
	GradientStop*                  AsGradientStop ();
	GradientStopCollection*        AsGradientStopCollection ();
	ImageBrush*                    AsImageBrush ();
	Inline*                        AsInline ();
	Inlines*                       AsInlines ();
	KeyFrame*                      AsKeyFrame ();
	KeyFrameCollection*            AsKeyFrameCollection ();
	Line*                          AsLine ();
	LinearColorKeyFrame*           AsLinearColorKeyFrame ();
	LinearDoubleKeyFrame*          AsLinearDoubleKeyFrame ();
	LinearGradientBrush*           AsLinearGradientBrush ();
	LinearPointKeyFrame*           AsLinearPointKeyFrame ();
	LineGeometry*                  AsLineGeometry ();
	LineSegment*                   AsLineSegment ();
	MatrixTransform*               AsMatrixTransform ();
	MediaAttribute*                AsMediaAttribute ();
	MediaAttributeCollection*      AsMediaAttributeCollection ();
	MediaBase*                     AsMediaBase ();
	MediaElement*                  AsMediaElement ();
	NameScope*                     AsNameScope ();
	Panel*                         AsPanel ();
	ParallelTimeline*              AsParallelTimeline ();
	Path*                          AsPath ();
	PathFigure*                    AsPathFigure ();
	PathFigureCollection*          AsPathFigureCollection ();
	PathGeometry*                  AsPathGeometry ();
	PathSegment*                   AsPathSegment ();
	PathSegmentCollection*         AsPathSegmentCollection ();
	PointAnimation*                AsPointAnimation ();
	PointAnimationUsingKeyFrames*  AsPointAnimationUsingKeyFrames ();
	PointKeyFrame*                 AsPointKeyFrame ();
	PolyBezierSegment*             AsPolyBezierSegment ();
	Polygon*                       AsPolygon ();
	Polyline*                      AsPolyline ();
	PolyLineSegment*               AsPolyLineSegment ();
	PolyQuadraticBezierSegment*    AsPolyQuadraticBezierSegment ();
	QuadraticBezierSegment*        AsQuadraticBezierSegment ();
	RadialGradientBrush*           AsRadialGradientBrush ();
	Rectangle*                     AsRectangle ();
	RectangleGeometry*             AsRectangleGeometry ();
	ResourceCollection*            AsResourceCollection ();
	RotateTransform*               AsRotateTransform ();
	ScaleTransform*                AsScaleTransform ();
	Shape*                         AsShape ();
	SkewTransform*                 AsSkewTransform ();
	SolidColorBrush*               AsSolidColorBrush ();
	Storyboard*                    AsStoryboard ();
	StrokeCollection*              AsStrokeCollection ();
	StylusPointCollection*         AsStylusPointCollection ();
	TextBlock*                     AsTextBlock ();
	TileBrush*                     AsTileBrush ();
	Timeline*                      AsTimeline ();
	TimelineCollection*            AsTimelineCollection ();
	TimelineGroup*                 AsTimelineGroup ();
	TimelineMarkerCollection*      AsTimelineMarkerCollection ();
	Transform*                     AsTransform ();
	TransformCollection*           AsTransformCollection ();
	TransformGroup*                AsTransformGroup ();
	TranslateTransform*            AsTranslateTransform ();
	TriggerAction*                 AsTriggerAction ();
	TriggerActionCollection*       AsTriggerActionCollection ();
	TriggerCollection*             AsTriggerCollection ();
	UIElement*                     AsUIElement ();
	VideoBrush*                    AsVideoBrush ();
	Visual*                        AsVisual ();
	VisualCollection*              AsVisualCollection ();

  
	Kind k;
  private:
	union {
		double d;
		guint64 ui64;
		gint64 i64;
		gint32 i32;
		char *s;
		DependencyObject *dependency_object;
		Color *color;
		Point *point;
		Rect *rect;
		RepeatBehavior *repeat;
		Duration *duration;
		KeyTime *keytime;
		PointArray *point_array;
		DoubleArray *double_array;
		Matrix* matrix;
	} u;


	// You don't want to be using this ctor.  it's here to help
	// c++ recognize bad unspecified pointer args to Value ctors
	// (it normally converts them to bool, which we handle, so you
	// never see the error of your ways).  So do the world a
	// favor, and don't expose this ctor. :)
	Value (void* v) { }
};


#endif /* MOON_VALUE_H */
