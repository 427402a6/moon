/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
/*
 * multiscalesubimage.cpp
 *
 * Contact:
 *   Moonlight List (moonlight-list@lists.ximian.com)
 *
 * Copyright 2007-2008 Novell, Inc. (http://www.novell.com)
 *
 * See the LICENSE file included with the distribution for details.
 * 
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <glib.h>

#include "debug.h"
#include "runtime.h"
#include "deepzoomimagetilesource.h"
#include "multiscalesubimage.h"

MultiScaleSubImage::MultiScaleSubImage ()
{
	SetObjectType (Type::MULTISCALESUBIMAGE);
	zoom_sb = NULL;
	pan_sb = NULL;
	source = NULL;	
}

MultiScaleSubImage::MultiScaleSubImage (const char* parent_uri, MultiScaleTileSource *tsource, int _id, int _n)
{
	LOG_MSI ("new MultiScaleSubImage ()\n");
	SetObjectType (Type::MULTISCALESUBIMAGE);
	source = tsource;
	id = _id;
	n = _n;
	zoom_sb = NULL;
	pan_sb = NULL;

	//FIXME: for now I strip the latest part of parent_uri and concat the uri from tsource.
	//it seems to work for images generated by DeepZoom, but it's not bulletproof
	if (g_str_has_prefix (((DeepZoomImageTileSource*)source)->GetUriSource (), "http://"))
		return;
	const char *urisource = ((DeepZoomImageTileSource*)source)->GetUriSource ();
	char buffer [strlen (parent_uri) + strlen (urisource)];
	strcpy (buffer, parent_uri);
	char *p = g_strrstr (buffer, "/");
	if (!p)
		return;

	strcpy (p + 1, urisource);
	LOG_MSI ("UriSource changed to %s (from %s)\n", buffer, urisource);
	((DeepZoomImageTileSource*)source)->SetUriSource (g_strdup (buffer));
}

double
MultiScaleSubImage::GetViewportHeight ()
{
	return GetAspectRatio () * GetViewportWidth ();
}

void
MultiScaleSubImage::OnPropertyChanged (PropertyChangedEventArgs *args, MoonError *error)
{
	if (args->GetId () == MultiScaleSubImage::ViewportOriginProperty) {
		Point *p = args->new_value->AsPoint();
		if (parent)
			parent->Invalidate ();
	}

	if (args->GetId () == MultiScaleSubImage::ViewportWidthProperty) {
		if (parent)
			parent->Invalidate ();
	}

	if (args->GetProperty ()->GetOwnerType () != Type::MULTISCALESUBIMAGE) {
		DependencyObject::OnPropertyChanged (args, error);
		return;
	}
	
	NotifyListenersOfPropertyChange (args);
}

void
MultiScaleSubImage::SetViewportOrigin (Point value)
{
	//SetValue (MultiScaleSubImage::ViewportOriginProperty, Value (*value));

	if (!pan_sb) {
		pan_sb = new Storyboard ();
		pan_sb->SetManualTarget (this);
		pan_sb->SetTargetProperty (pan_sb, new PropertyPath ("(MultiScaleImage.ViewportOrigin)"));
		pan_animation = new PointAnimation ();
		pan_animation->SetDuration (Duration::FromSecondsFloat (.4));
		TimelineCollection *tlc = new TimelineCollection ();
		tlc->Add (pan_animation);
		pan_sb->SetChildren(tlc);
	} else
		pan_sb->Pause ();

	pan_animation->SetFrom (GetViewportOrigin());
	pan_animation->SetTo (value);

	pan_sb->Begin ();
}

void
MultiScaleSubImage::SetViewportWidth (double value)
{
//	SetValue (MultiScaleSubImage::ViewportWidthProperty, Value (value));
	if (!zoom_sb) {
		zoom_sb = new Storyboard ();
		zoom_sb->SetManualTarget (this);
		zoom_sb->SetTargetProperty (zoom_sb, new PropertyPath ("(MultiScaleImage.ViewportWidth)"));
		zoom_animation = new DoubleAnimation ();
		zoom_animation->SetDuration (Duration::FromSecondsFloat (.4));
		TimelineCollection *tlc = new TimelineCollection ();
		tlc->Add (zoom_animation);
		zoom_sb->SetChildren(tlc);
	} else {
		zoom_sb->Pause ();
	}

	LOG_MSI ("animating zoom from %f to %f\n\n", GetViewportWidth(), value)	
	zoom_animation->SetFrom (GetViewportWidth ());
	zoom_animation->SetTo (value);

	zoom_sb->Begin();
}


