/*
 * Automatically generated, do not edit this file directly
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#include "cbinding.h"

/**
 * Application
 **/
Application *
application_new (void)
{
	return new Application ();
}


Application *
application_get_current (void)
{
	return Application::GetCurrent ();
}


void
application_register_callbacks (Application *instance, ApplyDefaultStyleCallback apply_default_style_cb, ApplyStyleCallback apply_style_cb, GetResourceCallback get_resource_cb)
{
	if (instance == NULL)
		return;
	
	instance->RegisterCallbacks (apply_default_style_cb, apply_style_cb, get_resource_cb);
}


void
application_set_current (Application *current)
{
	Application::SetCurrent (current);
}


/**
 * ArcSegment
 **/
ArcSegment *
arc_segment_new (void)
{
	return new ArcSegment ();
}


/**
 * AssemblyPart
 **/
AssemblyPart *
assembly_part_new (void)
{
	return new AssemblyPart ();
}


/**
 * AssemblyPartCollection
 **/
AssemblyPartCollection *
assembly_part_collection_new (void)
{
	return new AssemblyPartCollection ();
}


/**
 * AudioStream
 **/
AudioStream *
audio_stream_new (Media *media, int codec_id, int bits_per_sample, int block_align, int sample_rate, int channels, int bit_rate, gpointer extra_data, guint32 extra_data_size)
{
	return new AudioStream (media, codec_id, bits_per_sample, block_align, sample_rate, channels, bit_rate, extra_data, extra_data_size);
}


/**
 * BackEase
 **/
BackEase *
back_ease_new (void)
{
	return new BackEase ();
}


double
back_ease_ease_in_core (BackEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * BeginStoryboard
 **/
BeginStoryboard *
begin_storyboard_new (void)
{
	return new BeginStoryboard ();
}


/**
 * BezierSegment
 **/
BezierSegment *
bezier_segment_new (void)
{
	return new BezierSegment ();
}


/**
 * BitmapImage
 **/
BitmapImage *
bitmap_image_new (void)
{
	return new BitmapImage ();
}


void
bitmap_image_pixbuf_write (BitmapImage *instance, gpointer buffer, gint32 offset, gint32 n)
{
	if (instance == NULL)
		return;
	
	instance->PixbufWrite (buffer, offset, n);
}


void
bitmap_image_pixmap_complete (BitmapImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->PixmapComplete ();
}


/**
 * BitmapSource
 **/
BitmapSource *
bitmap_source_new (void)
{
	return new BitmapSource ();
}


void
bitmap_source_invalidate (BitmapSource *instance)
{
	if (instance == NULL)
		return;
	
	instance->Invalidate ();
}


void
bitmap_source_set_bitmap_data (BitmapSource *instance, gpointer data)
{
	if (instance == NULL)
		return;
	
	instance->SetBitmapData (data);
}


/**
 * Border
 **/
Border *
border_new (void)
{
	return new Border ();
}


/**
 * BounceEase
 **/
BounceEase *
bounce_ease_new (void)
{
	return new BounceEase ();
}


double
bounce_ease_ease_in_core (BounceEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * Brush
 **/
Brush *
brush_new (void)
{
	return new Brush ();
}


/**
 * Canvas
 **/
Canvas *
canvas_new (void)
{
	return new Canvas ();
}


/**
 * CircleEase
 **/
CircleEase *
circle_ease_new (void)
{
	return new CircleEase ();
}


double
circle_ease_ease_in_core (CircleEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * Collection
 **/
int
collection_add_with_error (Collection *instance, Value *value, MoonError *error)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_add_with_error () with error == NULL.");
	return instance->AddWithError (value, error);
}


bool
collection_clear (Collection *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Clear ();
}


bool
collection_contains (Collection *instance, Value *value)
{
	if (instance == NULL)
		return false;
	
	return instance->Contains (value);
}


int
collection_get_count (Collection *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetCount ();
}


Type::Kind
collection_get_element_type (Collection *instance)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->GetElementType ();
}


CollectionIterator *
collection_get_iterator (Collection *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetIterator ();
}


Value *
collection_get_value_at_with_error (Collection *instance, int index, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_get_value_at_with_error () with error == NULL.");
	return instance->GetValueAtWithError (index, error);
}


int
collection_index_of (Collection *instance, Value *value)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->IndexOf (value);
}


bool
collection_insert_with_error (Collection *instance, int index, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_insert_with_error () with error == NULL.");
	return instance->InsertWithError (index, value, error);
}


bool
collection_remove (Collection *instance, Value *value)
{
	if (instance == NULL)
		return false;
	
	return instance->Remove (value);
}


bool
collection_remove_at_with_error (Collection *instance, int index, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_remove_at_with_error () with error == NULL.");
	return instance->RemoveAtWithError (index, error);
}


bool
collection_set_value_at_with_error (Collection *instance, int index, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_set_value_at_with_error () with error == NULL.");
	return instance->SetValueAtWithError (index, value, error);
}


/**
 * CollectionChangedEventArgs
 **/
CollectionChangedEventArgs *
collection_changed_event_args_new (void)
{
	return new CollectionChangedEventArgs ();
}


CollectionChangedAction
collection_changed_event_args_get_changed_action (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (CollectionChangedAction) 0;
	
	return instance->GetChangedAction ();
}


int
collection_changed_event_args_get_index (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetIndex ();
}


Value *
collection_changed_event_args_get_new_item (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetNewItem ();
}


Value *
collection_changed_event_args_get_old_item (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetOldItem ();
}


void
collection_changed_event_args_set_changed_action (CollectionChangedEventArgs *instance, CollectionChangedAction action)
{
	if (instance == NULL)
		return;
	
	instance->SetChangedAction (action);
}


void
collection_changed_event_args_set_index (CollectionChangedEventArgs *instance, int index)
{
	if (instance == NULL)
		return;
	
	instance->SetIndex (index);
}


void
collection_changed_event_args_set_new_item (CollectionChangedEventArgs *instance, Value *item)
{
	if (instance == NULL)
		return;
	
	instance->SetNewItem (item);
}


void
collection_changed_event_args_set_old_item (CollectionChangedEventArgs *instance, Value *item)
{
	if (instance == NULL)
		return;
	
	instance->SetOldItem (item);
}


/**
 * CollectionIterator
 **/
void
collection_iterator_destroy (CollectionIterator *iterator)
{
	CollectionIterator::Destroy (iterator);
}


Value *
collection_iterator_get_current (CollectionIterator *instance, int *error)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetCurrent (error);
}


int
collection_iterator_next (CollectionIterator *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->Next ();
}


bool
collection_iterator_reset (CollectionIterator *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Reset ();
}


/**
 * ColorAnimation
 **/
ColorAnimation *
color_animation_new (void)
{
	return new ColorAnimation ();
}


/**
 * ColorAnimationUsingKeyFrames
 **/
ColorAnimationUsingKeyFrames *
color_animation_using_key_frames_new (void)
{
	return new ColorAnimationUsingKeyFrames ();
}


/**
 * ColorKeyFrame
 **/
ColorKeyFrame *
color_key_frame_new (void)
{
	return new ColorKeyFrame ();
}


/**
 * ColorKeyFrameCollection
 **/
ColorKeyFrameCollection *
color_key_frame_collection_new (void)
{
	return new ColorKeyFrameCollection ();
}


/**
 * ColumnDefinition
 **/
ColumnDefinition *
column_definition_new (void)
{
	return new ColumnDefinition ();
}


double
column_definition_get_actual_width (ColumnDefinition *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetActualWidth ();
}


/**
 * ColumnDefinitionCollection
 **/
ColumnDefinitionCollection *
column_definition_collection_new (void)
{
	return new ColumnDefinitionCollection ();
}


/**
 * ContentChangedEventArgs
 **/
Value *
content_changed_event_args_get_new_content (ContentChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetNewContent ();
}


Value *
content_changed_event_args_get_old_content (ContentChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetOldContent ();
}


/**
 * ContentControl
 **/
ContentControl *
content_control_new (void)
{
	return new ContentControl ();
}


/**
 * Control
 **/
bool
control_apply_template (Control *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->ApplyTemplate ();
}


Control *
control_new (void)
{
	return new Control ();
}


bool
control_focus (Control *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Focus ();
}


DependencyObject *
control_get_template_child (Control *instance, const char *name)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTemplateChild (name);
}


/**
 * ControlTemplate
 **/
ControlTemplate *
control_template_new (void)
{
	return new ControlTemplate ();
}


/**
 * CubicEase
 **/
CubicEase *
cubic_ease_new (void)
{
	return new CubicEase ();
}


double
cubic_ease_ease_in_core (CubicEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * CursorPositionChangedEventArgs
 **/
CursorPositionChangedEventArgs *
cursor_position_changed_event_args_new (void)
{
	return new CursorPositionChangedEventArgs ();
}


double
cursor_position_changed_event_args_get_cursor_height (CursorPositionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetCursorHeight ();
}


double
cursor_position_changed_event_args_get_cursor_x (CursorPositionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetCursorX ();
}


double
cursor_position_changed_event_args_get_cursor_y (CursorPositionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetCursorY ();
}


/**
 * DataTemplate
 **/
DataTemplate *
data_template_new (void)
{
	return new DataTemplate ();
}


DependencyObject *
data_template_load_content_with_error (DataTemplate *instance, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called data_template_load_content_with_error () with error == NULL.");
	return instance->LoadContentWithError (error);
}


/**
 * DeepZoomImageTileSource
 **/
DeepZoomImageTileSource *
deep_zoom_image_tile_source_new (void)
{
	return new DeepZoomImageTileSource ();
}


/**
 * DependencyObject
 **/
void
dependency_object_clear_value (DependencyObject *instance, DependencyProperty *property, bool notify_listeners, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_clear_value () with error == NULL.");
	instance->ClearValue (property, notify_listeners, error);
}


DependencyObject *
dependency_object_new (void)
{
	return new DependencyObject ();
}


DependencyObject *
dependency_object_find_name (DependencyObject *instance, const char *name, Type::Kind *element_kind)
{
	if (instance == NULL)
		return NULL;
	
	return instance->FindName (name, element_kind);
}


const char *
dependency_object_get_name (DependencyObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetName ();
}


Value *
dependency_object_get_value_no_default_with_error (DependencyObject *instance, DependencyProperty *property, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_get_value_no_default_with_error () with error == NULL.");
	return instance->GetValueNoDefaultWithError (property, error);
}


Value *
dependency_object_get_value_with_error (DependencyObject *instance, Type::Kind whatami, DependencyProperty *property, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_get_value_with_error () with error == NULL.");
	return instance->GetValueWithError (whatami, property, error);
}


Value *
dependency_object_read_local_value_with_error (DependencyObject *instance, DependencyProperty *property, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_read_local_value_with_error () with error == NULL.");
	return instance->ReadLocalValueWithError (property, error);
}


void
dependency_object_set_name (DependencyObject *instance, const char *name)
{
	if (instance == NULL)
		return;
	
	instance->SetName (name);
}


void
dependency_object_set_parent (DependencyObject *instance, DependencyObject *parent, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_set_parent () with error == NULL.");
	instance->SetParent (parent, error);
}


bool
dependency_object_set_value_with_error (DependencyObject *instance, DependencyProperty *property, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_set_value_with_error () with error == NULL.");
	return instance->SetValueWithError (property, value, error);
}


/**
 * DependencyObjectCollection
 **/
DependencyObjectCollection *
dependency_object_collection_new (void)
{
	return new DependencyObjectCollection ();
}


/**
 * DependencyProperty
 **/
Value *
dependency_property_get_default_value (DependencyProperty *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetDefaultValue ();
}


DependencyProperty *
dependency_property_get_dependency_property (Type::Kind type, const char *name)
{
	return DependencyProperty::GetDependencyProperty (type, name);
}


DependencyProperty *
dependency_property_get_dependency_property_full (Type::Kind type, const char *name, bool inherits)
{
	return DependencyProperty::GetDependencyPropertyFull (type, name, inherits);
}


const char *
dependency_property_get_name (DependencyProperty *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetName ();
}


Type::Kind
dependency_property_get_property_type (DependencyProperty *instance)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->GetPropertyType ();
}


bool
dependency_property_is_attached (DependencyProperty *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsAttached ();
}


bool
dependency_property_is_nullable (DependencyProperty *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsNullable ();
}


bool
dependency_property_is_read_only (DependencyProperty *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsReadOnly ();
}


DependencyProperty *
dependency_property_register_managed_property (const char *name, Type::Kind property_type, Type::Kind owner_type, Value *defaultValue, bool attached, bool read_only, NativePropertyChangedHandler *callback)
{
	return DependencyProperty::RegisterManagedProperty (name, property_type, owner_type, defaultValue, attached, read_only, callback);
}


void
dependency_property_set_is_nullable (DependencyProperty *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetIsNullable (value);
}


void
dependency_property_set_property_changed_callback (DependencyProperty *instance, NativePropertyChangedHandler *changed_callback)
{
	if (instance == NULL)
		return;
	
	instance->SetPropertyChangedCallback (changed_callback);
}


/**
 * Deployment
 **/
Deployment *
deployment_new (void)
{
	return new Deployment ();
}


Deployment *
deployment_get_current (void)
{
	return Deployment::GetCurrent ();
}


Types *
deployment_get_types (Deployment *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTypes ();
}


void
deployment_set_current (Deployment *value)
{
	Deployment::SetCurrent (value);
}


void
deployment_set_current_application (Deployment *instance, Application *value)
{
	if (instance == NULL)
		return;
	
	instance->SetCurrentApplication (value);
}


/**
 * DiscreteColorKeyFrame
 **/
DiscreteColorKeyFrame *
discrete_color_key_frame_new (void)
{
	return new DiscreteColorKeyFrame ();
}


/**
 * DiscreteDoubleKeyFrame
 **/
DiscreteDoubleKeyFrame *
discrete_double_key_frame_new (void)
{
	return new DiscreteDoubleKeyFrame ();
}


/**
 * DiscreteObjectKeyFrame
 **/
DiscreteObjectKeyFrame *
discrete_object_key_frame_new (void)
{
	return new DiscreteObjectKeyFrame ();
}


/**
 * DiscretePointKeyFrame
 **/
DiscretePointKeyFrame *
discrete_point_key_frame_new (void)
{
	return new DiscretePointKeyFrame ();
}


/**
 * DispatcherTimer
 **/
DispatcherTimer *
dispatcher_timer_new (void)
{
	return new DispatcherTimer ();
}


void
dispatcher_timer_start (DispatcherTimer *instance)
{
	if (instance == NULL)
		return;
	
	instance->Start ();
}


void
dispatcher_timer_stop (DispatcherTimer *instance)
{
	if (instance == NULL)
		return;
	
	instance->Stop ();
}


/**
 * DoubleAnimation
 **/
DoubleAnimation *
double_animation_new (void)
{
	return new DoubleAnimation ();
}


/**
 * DoubleAnimationUsingKeyFrames
 **/
DoubleAnimationUsingKeyFrames *
double_animation_using_key_frames_new (void)
{
	return new DoubleAnimationUsingKeyFrames ();
}


/**
 * DoubleCollection
 **/
DoubleCollection *
double_collection_new (void)
{
	return new DoubleCollection ();
}


/**
 * DoubleKeyFrame
 **/
DoubleKeyFrame *
double_key_frame_new (void)
{
	return new DoubleKeyFrame ();
}


/**
 * DoubleKeyFrameCollection
 **/
DoubleKeyFrameCollection *
double_key_frame_collection_new (void)
{
	return new DoubleKeyFrameCollection ();
}


/**
 * Downloader
 **/
Downloader *
downloader_new (void)
{
	return new Downloader ();
}


void
downloader_notify_failed (Downloader *instance, const char *msg)
{
	if (instance == NULL)
		return;
	
	instance->NotifyFailed (msg);
}


void
downloader_notify_finished (Downloader *instance, const char *final_uri)
{
	if (instance == NULL)
		return;
	
	instance->NotifyFinished (final_uri);
}


void
downloader_notify_size (Downloader *instance, gint64 size)
{
	if (instance == NULL)
		return;
	
	instance->NotifySize (size);
}


void
downloader_set_functions (DownloaderCreateStateFunc create_state, DownloaderDestroyStateFunc destroy_state, DownloaderOpenFunc open, DownloaderSendFunc send, DownloaderAbortFunc abort, DownloaderHeaderFunc header, DownloaderBodyFunc body, DownloaderCreateWebRequestFunc request, bool only_if_not_set)
{
	Downloader::SetFunctions (create_state, destroy_state, open, send, abort, header, body, request, only_if_not_set);
}


void
downloader_write (Downloader *instance, void *buf, gint32 offset, gint32 n)
{
	if (instance == NULL)
		return;
	
	instance->Write (buf, offset, n);
}


/**
 * DownloaderRequest
 **/
void
downloader_request_free (DownloaderRequest *instance)
{
	delete instance;
}


void
downloader_request_abort (DownloaderRequest *instance)
{
	if (instance == NULL)
		return;
	
	instance->Abort ();
}


/**
 * DownloaderResponse
 **/
void
downloader_response_free (DownloaderResponse *instance)
{
	delete instance;
}


void
downloader_response_abort (DownloaderResponse *instance)
{
	if (instance == NULL)
		return;
	
	instance->Abort ();
}


int
downloader_response_get_response_status (DownloaderResponse *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetResponseStatus ();
}


const char *
downloader_response_get_response_status_text (DownloaderResponse *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetResponseStatusText ();
}


/**
 * DownloadProgressEventArgs
 **/
double
download_progress_event_args_get_progress (DownloadProgressEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetProgress ();
}


/**
 * DrawingAttributes
 **/
DrawingAttributes *
drawing_attributes_new (void)
{
	return new DrawingAttributes ();
}


/**
 * EasingColorKeyFrame
 **/
EasingColorKeyFrame *
easing_color_key_frame_new (void)
{
	return new EasingColorKeyFrame ();
}


/**
 * EasingDoubleKeyFrame
 **/
EasingDoubleKeyFrame *
easing_double_key_frame_new (void)
{
	return new EasingDoubleKeyFrame ();
}


/**
 * EasingFunctionBase
 **/
EasingFunctionBase *
easing_function_base_new (void)
{
	return new EasingFunctionBase ();
}


void
easing_function_base_set_easing_function (EasingFunctionBase *instance, EasingFunction value)
{
	if (instance == NULL)
		return;
	
	instance->SetEasingFunction (value);
}


/**
 * EasingPointKeyFrame
 **/
EasingPointKeyFrame *
easing_point_key_frame_new (void)
{
	return new EasingPointKeyFrame ();
}


/**
 * ElasticEase
 **/
double
elastic_ease_ease_in_core (ElasticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


ElasticEase *
elastic_ease_new (void)
{
	return new ElasticEase ();
}


/**
 * Ellipse
 **/
Ellipse *
ellipse_new (void)
{
	return new Ellipse ();
}


/**
 * EllipseGeometry
 **/
EllipseGeometry *
ellipse_geometry_new (void)
{
	return new EllipseGeometry ();
}


/**
 * EventObject
 **/
int
event_object_add_handler (EventObject *instance, const char *event_name, EventHandler handler, gpointer data, GDestroyNotify data_dtor)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->AddHandler (event_name, handler, data, data_dtor);
}


void
event_object_add_toggle_ref_notifier (EventObject *instance, ToggleNotifyHandler tr)
{
	if (instance == NULL)
		return;
	
	instance->AddToggleRefNotifier (tr);
}


int
event_object_add_xaml_handler (EventObject *instance, const char *event_name, EventHandler handler, gpointer data, GDestroyNotify data_dtor)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->AddXamlHandler (event_name, handler, data, data_dtor);
}


Type::Kind
event_object_get_object_type (EventObject *instance)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->GetObjectType ();
}


Surface *
event_object_get_surface (EventObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSurface ();
}


const char *
event_object_get_type_name (EventObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTypeName ();
}


void
event_object_ref (EventObject *instance)
{
	if (instance == NULL)
		return;
	
	instance->ref ();
}


void
event_object_remove_handler (EventObject *instance, const char *event_name, EventHandler handler, gpointer data)
{
	if (instance == NULL)
		return;
	
	instance->RemoveHandler (event_name, handler, data);
}


void
event_object_remove_toggle_ref_notifier (EventObject *instance)
{
	if (instance == NULL)
		return;
	
	instance->RemoveToggleRefNotifier ();
}


void
event_object_set_object_type (EventObject *instance, Type::Kind value)
{
	if (instance == NULL)
		return;
	
	instance->SetObjectType (value);
}


void
event_object_unref (EventObject *instance)
{
	if (instance == NULL)
		return;
	
	instance->unref ();
}


/**
 * EventTrigger
 **/
EventTrigger *
event_trigger_new (void)
{
	return new EventTrigger ();
}


/**
 * ExponentialEase
 **/
double
exponential_ease_ease_in_core (ExponentialEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


ExponentialEase *
exponential_ease_new (void)
{
	return new ExponentialEase ();
}


/**
 * ExternalDemuxer
 **/
gint32
external_demuxer_add_stream (ExternalDemuxer *instance, IMediaStream *stream)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gint32) 0;
	
	return instance->AddStream (stream);
}


void
external_demuxer_set_can_seek (ExternalDemuxer *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetCanSeek (value);
}


/**
 * FrameworkElement
 **/
Size
framework_element_arrange_override (FrameworkElement *instance, Size finalSize)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->ArrangeOverride (finalSize);
}


FrameworkElement *
framework_element_new (void)
{
	return new FrameworkElement ();
}


DependencyObject *
framework_element_get_logical_parent (FrameworkElement *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetLogicalParent ();
}


Size
framework_element_measure_override (FrameworkElement *instance, Size availableSize)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->MeasureOverride (availableSize);
}


void
framework_element_register_managed_overrides (FrameworkElement *instance, MeasureOverrideCallback measure_cb, ArrangeOverrideCallback arrange_cb)
{
	if (instance == NULL)
		return;
	
	instance->RegisterManagedOverrides (measure_cb, arrange_cb);
}


void
framework_element_set_default_style (FrameworkElement *instance, Style *value)
{
	if (instance == NULL)
		return;
	
	instance->SetDefaultStyle (value);
}


void
framework_element_set_logical_parent (FrameworkElement *instance, DependencyObject *logical_parent, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called framework_element_set_logical_parent () with error == NULL.");
	instance->SetLogicalParent (logical_parent, error);
}


/**
 * FrameworkTemplate
 **/
void
framework_template_add_xaml_binding (FrameworkTemplate *instance, FrameworkElement *target, const char *target_prop_name, const char *source_prop_name)
{
	if (instance == NULL)
		return;
	
	instance->AddXamlBinding (target, target_prop_name, source_prop_name);
}


FrameworkTemplate *
framework_template_new (void)
{
	return new FrameworkTemplate ();
}


/**
 * GeneralTransform
 **/
GeneralTransform *
general_transform_new (void)
{
	return new GeneralTransform ();
}


Matrix *
general_transform_get_matrix (GeneralTransform *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMatrix ();
}


/**
 * Geometry
 **/
Geometry *
geometry_new (void)
{
	return new Geometry ();
}


Rect
geometry_get_bounds (Geometry *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Rect) 0;
	
	return instance->GetBounds ();
}


/**
 * GeometryCollection
 **/
GeometryCollection *
geometry_collection_new (void)
{
	return new GeometryCollection ();
}


/**
 * GeometryGroup
 **/
GeometryGroup *
geometry_group_new (void)
{
	return new GeometryGroup ();
}


/**
 * Glyphs
 **/
Glyphs *
glyphs_new (void)
{
	return new Glyphs ();
}


/**
 * GradientBrush
 **/
GradientBrush *
gradient_brush_new (void)
{
	return new GradientBrush ();
}


/**
 * GradientStop
 **/
GradientStop *
gradient_stop_new (void)
{
	return new GradientStop ();
}


/**
 * GradientStopCollection
 **/
GradientStopCollection *
gradient_stop_collection_new (void)
{
	return new GradientStopCollection ();
}


/**
 * Grid
 **/
Grid *
grid_new (void)
{
	return new Grid ();
}


/**
 * HitTestCollection
 **/
HitTestCollection *
hit_test_collection_new (void)
{
	return new HitTestCollection ();
}


/**
 * Image
 **/
Image *
image_new (void)
{
	return new Image ();
}


void
image_set_source (Image *instance, ImageSource *source)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (source);
}


/**
 * ImageBrush
 **/
ImageBrush *
image_brush_new (void)
{
	return new ImageBrush ();
}


/**
 * ImageSource
 **/
ImageSource *
image_source_new (void)
{
	return new ImageSource ();
}


/**
 * IMediaDemuxer
 **/
void
imedia_demuxer_report_get_diagnostic_completed (IMediaDemuxer *instance, MediaStreamSourceDiagnosticKind diagnosticKind, gint64 diagnosticValue)
{
	if (instance == NULL)
		return;
	
	instance->ReportGetDiagnosticCompleted (diagnosticKind, diagnosticValue);
}


void
imedia_demuxer_report_get_frame_completed (IMediaDemuxer *instance, MediaFrame *frame)
{
	if (instance == NULL)
		return;
	
	instance->ReportGetFrameCompleted (frame);
}


void
imedia_demuxer_report_get_frame_progress (IMediaDemuxer *instance, double bufferingProgress)
{
	if (instance == NULL)
		return;
	
	instance->ReportGetFrameProgress (bufferingProgress);
}


void
imedia_demuxer_report_open_demuxer_completed (IMediaDemuxer *instance)
{
	if (instance == NULL)
		return;
	
	instance->ReportOpenDemuxerCompleted ();
}


void
imedia_demuxer_report_seek_completed (IMediaDemuxer *instance, guint64 pts)
{
	if (instance == NULL)
		return;
	
	instance->ReportSeekCompleted (pts);
}


void
imedia_demuxer_report_switch_media_stream_completed (IMediaDemuxer *instance, IMediaStream *stream)
{
	if (instance == NULL)
		return;
	
	instance->ReportSwitchMediaStreamCompleted (stream);
}


/**
 * IMediaObject
 **/
Media *
imedia_object_get_media_reffed (IMediaObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMediaReffed ();
}


/**
 * InkPresenter
 **/
InkPresenter *
ink_presenter_new (void)
{
	return new InkPresenter ();
}


/**
 * Inline
 **/
Inline *
inline_new (void)
{
	return new Inline ();
}


/**
 * InlineCollection
 **/
InlineCollection *
inline_collection_new (void)
{
	return new InlineCollection ();
}


/**
 * InputMethod
 **/
InputMethod *
input_method_new (void)
{
	return new InputMethod ();
}


/**
 * ItemCollection
 **/
ItemCollection *
item_collection_new (void)
{
	return new ItemCollection ();
}


/**
 * Keyboard
 **/
ModifierKeys
keyboard_get_modifiers (void)
{
	return Keyboard::GetModifiers ();
}


/**
 * KeyEventArgs
 **/
int
key_event_args_get_key (KeyEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetKey ();
}


int
key_event_args_get_platform_key_code (KeyEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetPlatformKeyCode ();
}


KeyEventArgs *
key_event_args_new (void)
{
	return new KeyEventArgs ();
}


/**
 * KeyFrameCollection
 **/
KeyFrameCollection *
key_frame_collection_new (void)
{
	return new KeyFrameCollection ();
}


/**
 * KeySpline
 **/
KeySpline *
key_spline_new (void)
{
	return new KeySpline ();
}


/**
 * Line
 **/
Line *
line_new (void)
{
	return new Line ();
}


/**
 * LinearColorKeyFrame
 **/
LinearColorKeyFrame *
linear_color_key_frame_new (void)
{
	return new LinearColorKeyFrame ();
}


/**
 * LinearDoubleKeyFrame
 **/
LinearDoubleKeyFrame *
linear_double_key_frame_new (void)
{
	return new LinearDoubleKeyFrame ();
}


/**
 * LinearGradientBrush
 **/
LinearGradientBrush *
linear_gradient_brush_new (void)
{
	return new LinearGradientBrush ();
}


/**
 * LinearPointKeyFrame
 **/
LinearPointKeyFrame *
linear_point_key_frame_new (void)
{
	return new LinearPointKeyFrame ();
}


/**
 * LineBreak
 **/
LineBreak *
line_break_new (void)
{
	return new LineBreak ();
}


/**
 * LineGeometry
 **/
LineGeometry *
line_geometry_new (void)
{
	return new LineGeometry ();
}


/**
 * LineSegment
 **/
LineSegment *
line_segment_new (void)
{
	return new LineSegment ();
}


/**
 * Matrix
 **/
cairo_matrix_t *
matrix_get_matrix_values (Matrix *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMatrixValues ();
}


Matrix *
matrix_new (void)
{
	return new Matrix ();
}


/**
 * MatrixTransform
 **/
MatrixTransform *
matrix_transform_new (void)
{
	return new MatrixTransform ();
}


/**
 * MediaAttribute
 **/
MediaAttribute *
media_attribute_new (void)
{
	return new MediaAttribute ();
}


/**
 * MediaAttributeCollection
 **/
MediaAttribute *
media_attribute_collection_get_item_by_name (MediaAttributeCollection *instance, const char *name)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetItemByName (name);
}


MediaAttributeCollection *
media_attribute_collection_new (void)
{
	return new MediaAttributeCollection ();
}


/**
 * MediaBase
 **/
MediaBase *
media_base_new (void)
{
	return new MediaBase ();
}


void
media_base_set_source (MediaBase *instance, const char *uri)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (uri);
}


/**
 * MediaElement
 **/
MediaElement *
media_element_new (void)
{
	return new MediaElement ();
}


void
media_element_pause (MediaElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Pause ();
}


void
media_element_play (MediaElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Play ();
}


void
media_element_report_error_occurred (MediaElement *instance, const char *args)
{
	if (instance == NULL)
		return;
	
	instance->ReportErrorOccurred (args);
}


IMediaDemuxer *
media_element_set_demuxer_source (MediaElement *instance, void *context, CloseDemuxerCallback close_demuxer, GetDiagnosticAsyncCallback get_diagnostic, GetFrameAsyncCallback get_sample, OpenDemuxerAsyncCallback open_demuxer, SeekAsyncCallback seek, SwitchMediaStreamAsyncCallback switch_media_stream)
{
	if (instance == NULL)
		return NULL;
	
	return instance->SetDemuxerSource (context, close_demuxer, get_diagnostic, get_sample, open_demuxer, seek, switch_media_stream);
}


void
media_element_set_stream_source (MediaElement *instance, ManagedStreamCallbacks *stream)
{
	if (instance == NULL)
		return;
	
	instance->SetStreamSource (stream);
}


void
media_element_stop (MediaElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Stop ();
}


/**
 * MediaFrame
 **/
MediaFrame *
media_frame_new (IMediaStream *stream, guint8 *buffer, guint32 buflen, guint64 pts)
{
	return new MediaFrame (stream, buffer, buflen, pts);
}


/**
 * MoonWindow
 **/
bool
moon_window_get_transparent (MoonWindow *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetTransparent ();
}


void
moon_window_set_transparent (MoonWindow *instance, bool flag)
{
	if (instance == NULL)
		return;
	
	instance->SetTransparent (flag);
}


/**
 * MoonWindowGtk
 **/
GtkWidget *
moon_window_gtk_get_widget (MoonWindowGtk *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetWidget ();
}


MoonWindowGtk *
moon_window_gtk_new (bool fullscreen, int w, int h, MoonWindow *parent)
{
	return new MoonWindowGtk (fullscreen, w, h, parent);
}


/**
 * MouseEventArgs
 **/
void
mouse_event_args_get_position (MouseEventArgs *instance, UIElement *relative_to, double *x, double *y)
{
	if (instance == NULL)
		return;
	
	instance->GetPosition (relative_to, x, y);
}


StylusInfo *
mouse_event_args_get_stylus_info (MouseEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetStylusInfo ();
}


StylusPointCollection *
mouse_event_args_get_stylus_points (MouseEventArgs *instance, UIElement *ink_presenter)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetStylusPoints (ink_presenter);
}


MouseEventArgs *
mouse_event_args_new (void)
{
	return new MouseEventArgs ();
}


/**
 * MouseWheelEventArgs
 **/
int
mouse_wheel_event_args_get_wheel_delta (MouseWheelEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetWheelDelta ();
}


MouseWheelEventArgs *
mouse_wheel_event_args_new (void)
{
	return new MouseWheelEventArgs ();
}


/**
 * MultiScaleImage
 **/
Point
multi_scale_image_element_to_logical_point (MultiScaleImage *instance, Point elementPoint)
{
	if (instance == NULL)
		return Point (0, 0);
	
	return instance->ElementToLogicalPoint (elementPoint);
}


Point
multi_scale_image_logical_to_element_point (MultiScaleImage *instance, Point logicalPoint)
{
	if (instance == NULL)
		return Point (0, 0);
	
	return instance->LogicalToElementPoint (logicalPoint);
}


MultiScaleImage *
multi_scale_image_new (void)
{
	return new MultiScaleImage ();
}


void
multi_scale_image_set_viewport_origin (MultiScaleImage *instance, Point p)
{
	if (instance == NULL)
		return;
	
	instance->SetViewportOrigin (p);
}


void
multi_scale_image_set_viewport_width (MultiScaleImage *instance, double width)
{
	if (instance == NULL)
		return;
	
	instance->SetViewportWidth (width);
}


void
multi_scale_image_zoom_about_logical_point (MultiScaleImage *instance, double zoomIncrementFactor, double zoomCenterLogicalX, double zoomCenterLogicalY)
{
	if (instance == NULL)
		return;
	
	instance->ZoomAboutLogicalPoint (zoomIncrementFactor, zoomCenterLogicalX, zoomCenterLogicalY);
}


/**
 * MultiScaleSubImage
 **/
gint32
multi_scale_sub_image_get_zindex (MultiScaleSubImage *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gint32) 0;
	
	return instance->GetZIndex ();
}


MultiScaleSubImage *
multi_scale_sub_image_new (void)
{
	return new MultiScaleSubImage ();
}


/**
 * MultiScaleSubImageCollection
 **/
MultiScaleSubImageCollection *
multi_scale_sub_image_collection_new (void)
{
	return new MultiScaleSubImageCollection ();
}


/**
 * MultiScaleTileSource
 **/
long
multi_scale_tile_source_get_image_height (MultiScaleTileSource *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (long) 0;
	
	return instance->GetImageHeight ();
}


long
multi_scale_tile_source_get_image_width (MultiScaleTileSource *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (long) 0;
	
	return instance->GetImageWidth ();
}


int
multi_scale_tile_source_get_tile_height (MultiScaleTileSource *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetTileHeight ();
}


int
multi_scale_tile_source_get_tile_overlap (MultiScaleTileSource *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetTileOverlap ();
}


int
multi_scale_tile_source_get_tile_width (MultiScaleTileSource *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetTileWidth ();
}


MultiScaleTileSource *
multi_scale_tile_source_new (void)
{
	return new MultiScaleTileSource ();
}


void
multi_scale_tile_source_set_image_uri_func (MultiScaleTileSource *instance, get_image_uri_func func)
{
	if (instance == NULL)
		return;
	
	instance->set_image_uri_func (func);
}


void
multi_scale_tile_source_set_image_height (MultiScaleTileSource *instance, long height)
{
	if (instance == NULL)
		return;
	
	instance->SetImageHeight (height);
}


void
multi_scale_tile_source_set_image_width (MultiScaleTileSource *instance, long width)
{
	if (instance == NULL)
		return;
	
	instance->SetImageWidth (width);
}


void
multi_scale_tile_source_set_tile_height (MultiScaleTileSource *instance, int height)
{
	if (instance == NULL)
		return;
	
	instance->SetTileHeight (height);
}


void
multi_scale_tile_source_set_tile_overlap (MultiScaleTileSource *instance, int overlap)
{
	if (instance == NULL)
		return;
	
	instance->SetTileOverlap (overlap);
}


void
multi_scale_tile_source_set_tile_width (MultiScaleTileSource *instance, int width)
{
	if (instance == NULL)
		return;
	
	instance->SetTileWidth (width);
}


/**
 * ObjectAnimationUsingKeyFrames
 **/
ObjectAnimationUsingKeyFrames *
object_animation_using_key_frames_new (void)
{
	return new ObjectAnimationUsingKeyFrames ();
}


/**
 * ObjectKeyFrame
 **/
ObjectKeyFrame *
object_key_frame_new (void)
{
	return new ObjectKeyFrame ();
}


/**
 * ObjectKeyFrameCollection
 **/
ObjectKeyFrameCollection *
object_key_frame_collection_new (void)
{
	return new ObjectKeyFrameCollection ();
}


/**
 * Panel
 **/
Panel *
panel_new (void)
{
	return new Panel ();
}


/**
 * ParallelTimeline
 **/
ParallelTimeline *
parallel_timeline_new (void)
{
	return new ParallelTimeline ();
}


/**
 * PasswordBox
 **/
PasswordBox *
password_box_new (void)
{
	return new PasswordBox ();
}


/**
 * Path
 **/
Path *
path_new (void)
{
	return new Path ();
}


/**
 * PathFigure
 **/
PathFigure *
path_figure_new (void)
{
	return new PathFigure ();
}


/**
 * PathFigureCollection
 **/
PathFigureCollection *
path_figure_collection_new (void)
{
	return new PathFigureCollection ();
}


/**
 * PathGeometry
 **/
PathGeometry *
path_geometry_new (void)
{
	return new PathGeometry ();
}


/**
 * PathSegment
 **/
PathSegment *
path_segment_new (void)
{
	return new PathSegment ();
}


/**
 * PathSegmentCollection
 **/
PathSegmentCollection *
path_segment_collection_new (void)
{
	return new PathSegmentCollection ();
}


/**
 * PointAnimation
 **/
PointAnimation *
point_animation_new (void)
{
	return new PointAnimation ();
}


/**
 * PointAnimationUsingKeyFrames
 **/
PointAnimationUsingKeyFrames *
point_animation_using_key_frames_new (void)
{
	return new PointAnimationUsingKeyFrames ();
}


/**
 * PointCollection
 **/
PointCollection *
point_collection_new (void)
{
	return new PointCollection ();
}


/**
 * PointKeyFrame
 **/
PointKeyFrame *
point_key_frame_new (void)
{
	return new PointKeyFrame ();
}


/**
 * PointKeyFrameCollection
 **/
PointKeyFrameCollection *
point_key_frame_collection_new (void)
{
	return new PointKeyFrameCollection ();
}


/**
 * PolyBezierSegment
 **/
PolyBezierSegment *
poly_bezier_segment_new (void)
{
	return new PolyBezierSegment ();
}


void
poly_bezier_segment_set_points (PolyBezierSegment *instance, PointCollection *points)
{
	if (instance == NULL)
		return;
	
	instance->SetPoints (points);
}


/**
 * Polygon
 **/
Polygon *
polygon_new (void)
{
	return new Polygon ();
}


/**
 * Polyline
 **/
Polyline *
polyline_new (void)
{
	return new Polyline ();
}


/**
 * PolyLineSegment
 **/
PolyLineSegment *
poly_line_segment_new (void)
{
	return new PolyLineSegment ();
}


/**
 * PolyQuadraticBezierSegment
 **/
PolyQuadraticBezierSegment *
poly_quadratic_bezier_segment_new (void)
{
	return new PolyQuadraticBezierSegment ();
}


/**
 * Popup
 **/
Popup *
popup_new (void)
{
	return new Popup ();
}


/**
 * PowerEase
 **/
double
power_ease_ease_in_core (PowerEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


PowerEase *
power_ease_new (void)
{
	return new PowerEase ();
}


/**
 * QuadraticBezierSegment
 **/
QuadraticBezierSegment *
quadratic_bezier_segment_new (void)
{
	return new QuadraticBezierSegment ();
}


/**
 * QuadraticEase
 **/
double
quadratic_ease_ease_in_core (QuadraticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


QuadraticEase *
quadratic_ease_new (void)
{
	return new QuadraticEase ();
}


/**
 * QuarticEase
 **/
double
quartic_ease_ease_in_core (QuarticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


QuarticEase *
quartic_ease_new (void)
{
	return new QuarticEase ();
}


/**
 * QuinticEase
 **/
double
quintic_ease_ease_in_core (QuinticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


QuinticEase *
quintic_ease_new (void)
{
	return new QuinticEase ();
}


/**
 * RadialGradientBrush
 **/
RadialGradientBrush *
radial_gradient_brush_new (void)
{
	return new RadialGradientBrush ();
}


/**
 * Rectangle
 **/
Rectangle *
rectangle_new (void)
{
	return new Rectangle ();
}


/**
 * RectangleGeometry
 **/
RectangleGeometry *
rectangle_geometry_new (void)
{
	return new RectangleGeometry ();
}


/**
 * ResourceDictionary
 **/
bool
resource_dictionary_add_with_error (ResourceDictionary *instance, const char *key, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called resource_dictionary_add_with_error () with error == NULL.");
	return instance->AddWithError (key, value, error);
}


bool
resource_dictionary_clear (ResourceDictionary *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Clear ();
}


bool
resource_dictionary_contains_key (ResourceDictionary *instance, const char *key)
{
	if (instance == NULL)
		return false;
	
	return instance->ContainsKey (key);
}


Value *
resource_dictionary_get (ResourceDictionary *instance, const char *key, bool *exists)
{
	if (instance == NULL)
		return NULL;
	
	return instance->Get (key, exists);
}


bool
resource_dictionary_remove (ResourceDictionary *instance, const char *key)
{
	if (instance == NULL)
		return false;
	
	return instance->Remove (key);
}


ResourceDictionary *
resource_dictionary_new (void)
{
	return new ResourceDictionary ();
}


bool
resource_dictionary_set (ResourceDictionary *instance, const char *key, Value *value)
{
	if (instance == NULL)
		return false;
	
	return instance->Set (key, value);
}


/**
 * RotateTransform
 **/
RotateTransform *
rotate_transform_new (void)
{
	return new RotateTransform ();
}


/**
 * RoutedEventArgs
 **/
bool
routed_event_args_get_handled (RoutedEventArgs *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetHandled ();
}


DependencyObject *
routed_event_args_get_source (RoutedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSource ();
}


RoutedEventArgs *
routed_event_args_new (void)
{
	return new RoutedEventArgs ();
}


void
routed_event_args_set_handled (RoutedEventArgs *instance, bool handled)
{
	if (instance == NULL)
		return;
	
	instance->SetHandled (handled);
}


void
routed_event_args_set_source (RoutedEventArgs *instance, DependencyObject *el)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (el);
}


/**
 * RowDefinition
 **/
double
row_definition_get_actual_height (RowDefinition *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetActualHeight ();
}


RowDefinition *
row_definition_new (void)
{
	return new RowDefinition ();
}


/**
 * RowDefinitionCollection
 **/
RowDefinitionCollection *
row_definition_collection_new (void)
{
	return new RowDefinitionCollection ();
}


/**
 * Run
 **/
Run *
run_new (void)
{
	return new Run ();
}


/**
 * ScaleTransform
 **/
ScaleTransform *
scale_transform_new (void)
{
	return new ScaleTransform ();
}


/**
 * Setter
 **/
Setter *
setter_new (void)
{
	return new Setter ();
}


/**
 * SetterBase
 **/
SetterBase *
setter_base_new (void)
{
	return new SetterBase ();
}


/**
 * SetterBaseCollection
 **/
SetterBaseCollection *
setter_base_collection_new (void)
{
	return new SetterBaseCollection ();
}


/**
 * Shape
 **/
Shape *
shape_new (void)
{
	return new Shape ();
}


/**
 * SineEase
 **/
double
sine_ease_ease_in_core (SineEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


SineEase *
sine_ease_new (void)
{
	return new SineEase ();
}


/**
 * SizeChangedEventArgs
 **/
SizeChangedEventArgs *
size_changed_event_args_new (void)
{
	return new SizeChangedEventArgs ();
}


/**
 * SkewTransform
 **/
SkewTransform *
skew_transform_new (void)
{
	return new SkewTransform ();
}


/**
 * SolidColorBrush
 **/
SolidColorBrush *
solid_color_brush_new (void)
{
	return new SolidColorBrush ();
}


/**
 * SplineColorKeyFrame
 **/
SplineColorKeyFrame *
spline_color_key_frame_new (void)
{
	return new SplineColorKeyFrame ();
}


/**
 * SplineDoubleKeyFrame
 **/
SplineDoubleKeyFrame *
spline_double_key_frame_new (void)
{
	return new SplineDoubleKeyFrame ();
}


/**
 * SplinePointKeyFrame
 **/
SplinePointKeyFrame *
spline_point_key_frame_new (void)
{
	return new SplinePointKeyFrame ();
}


/**
 * Storyboard
 **/
bool
storyboard_begin_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_begin_with_error () with error == NULL.");
	return instance->BeginWithError (error);
}


int
storyboard_get_current_state (Storyboard *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetCurrentState ();
}


DependencyProperty *
storyboard_get_target_dependency_property (Storyboard *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTargetDependencyProperty ();
}


void
storyboard_pause_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_pause_with_error () with error == NULL.");
	instance->PauseWithError (error);
}


void
storyboard_resume_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_resume_with_error () with error == NULL.");
	instance->ResumeWithError (error);
}


void
storyboard_seek_with_error (Storyboard *instance, TimeSpan timespan, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_seek_with_error () with error == NULL.");
	instance->SeekWithError (timespan, error);
}


void
storyboard_skip_to_fill (Storyboard *instance)
{
	if (instance == NULL)
		return;
	
	instance->SkipToFill ();
}


void
storyboard_stop_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_stop_with_error () with error == NULL.");
	instance->StopWithError (error);
}


Storyboard *
storyboard_new (void)
{
	return new Storyboard ();
}


/**
 * Stroke
 **/
bool
stroke_hit_test (Stroke *instance, StylusPointCollection *stylusPoints)
{
	if (instance == NULL)
		return false;
	
	return instance->HitTest (stylusPoints);
}


Stroke *
stroke_new (void)
{
	return new Stroke ();
}


/**
 * StrokeCollection
 **/
StrokeCollection *
stroke_collection_hit_test (StrokeCollection *instance, StylusPointCollection *stylusPoints)
{
	if (instance == NULL)
		return NULL;
	
	return instance->HitTest (stylusPoints);
}


StrokeCollection *
stroke_collection_new (void)
{
	return new StrokeCollection ();
}


/**
 * Style
 **/
void
style_seal (Style *instance)
{
	if (instance == NULL)
		return;
	
	instance->Seal ();
}


Style *
style_new (void)
{
	return new Style ();
}


/**
 * StylusInfo
 **/
StylusInfo *
stylus_info_new (void)
{
	return new StylusInfo ();
}


/**
 * StylusPoint
 **/
double
stylus_point_get_pressure_factor (StylusPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetPressureFactor ();
}


double
stylus_point_get_x (StylusPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetX ();
}


double
stylus_point_get_y (StylusPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetY ();
}


void
stylus_point_set_pressure_factor (StylusPoint *instance, double factor)
{
	if (instance == NULL)
		return;
	
	instance->SetPressureFactor (factor);
}


void
stylus_point_set_x (StylusPoint *instance, double x)
{
	if (instance == NULL)
		return;
	
	instance->SetX (x);
}


void
stylus_point_set_y (StylusPoint *instance, double y)
{
	if (instance == NULL)
		return;
	
	instance->SetY (y);
}


StylusPoint *
stylus_point_new (void)
{
	return new StylusPoint ();
}


/**
 * StylusPointCollection
 **/
double
stylus_point_collection_add_stylus_points (StylusPointCollection *instance, StylusPointCollection *stylusPointCollection)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->AddStylusPoints (stylusPointCollection);
}


StylusPointCollection *
stylus_point_collection_new (void)
{
	return new StylusPointCollection ();
}


/**
 * Surface
 **/
void
surface_attach (Surface *instance, UIElement *toplevel)
{
	if (instance == NULL)
		return;
	
	instance->Attach (toplevel);
}


Downloader *
surface_create_downloader (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->CreateDownloader ();
}


Color *
surface_get_background_color (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetBackgroundColor ();
}


UIElement *
surface_get_focused_element (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetFocusedElement ();
}


bool
surface_get_full_screen (Surface *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetFullScreen ();
}


TimeManager *
surface_get_time_manager (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTimeManager ();
}


UIElement *
surface_get_toplevel (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetToplevel ();
}


MoonWindow *
surface_get_window (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetWindow ();
}


bool
surface_in_main_thread (void)
{
	return Surface::InMainThread ();
}


bool
surface_is_loaded (Surface *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsLoaded ();
}


bool
surface_is_version_supported (const char *version)
{
	return Surface::IsVersionSupported (version);
}


void
surface_paint (Surface *instance, cairo_t *ctx, int x, int y, int width, int height)
{
	if (instance == NULL)
		return;
	
	instance->Paint (ctx, x, y, width, height);
}


void
surface_resize (Surface *instance, int width, int height)
{
	if (instance == NULL)
		return;
	
	instance->Resize (width, height);
}


void
surface_set_full_screen (Surface *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetFullScreen (value);
}


Surface *
surface_new (MoonWindow *window)
{
	return new Surface (window);
}


/**
 * TextBlock
 **/
TextBlock *
text_block_new (void)
{
	return new TextBlock ();
}


/**
 * TextBox
 **/
TextBox *
text_box_new (void)
{
	return new TextBox ();
}


/**
 * TextBoxBase
 **/
void
text_box_base_select (TextBoxBase *instance, int start, int length)
{
	if (instance == NULL)
		return;
	
	instance->Select (start, length);
}


void
text_box_base_select_all (TextBoxBase *instance)
{
	if (instance == NULL)
		return;
	
	instance->SelectAll ();
}


/**
 * TextBoxView
 **/
TextBoxView *
text_box_view_new (void)
{
	return new TextBoxView ();
}


/**
 * TextChangedEventArgs
 **/
TextChangedEventArgs *
text_changed_event_args_new (void)
{
	return new TextChangedEventArgs ();
}


/**
 * TileBrush
 **/
TileBrush *
tile_brush_new (void)
{
	return new TileBrush ();
}


/**
 * Timeline
 **/
DependencyObject *
timeline_get_manual_target (Timeline *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetManualTarget ();
}


void
timeline_set_manual_target (Timeline *instance, DependencyObject *o)
{
	if (instance == NULL)
		return;
	
	instance->SetManualTarget (o);
}


Timeline *
timeline_new (void)
{
	return new Timeline ();
}


/**
 * TimelineCollection
 **/
TimelineCollection *
timeline_collection_new (void)
{
	return new TimelineCollection ();
}


/**
 * TimelineGroup
 **/
TimelineGroup *
timeline_group_new (void)
{
	return new TimelineGroup ();
}


/**
 * TimelineMarker
 **/
TimelineMarker *
timeline_marker_new (void)
{
	return new TimelineMarker ();
}


/**
 * TimelineMarkerCollection
 **/
TimelineMarkerCollection *
timeline_marker_collection_new (void)
{
	return new TimelineMarkerCollection ();
}


/**
 * TimeManager
 **/
void
time_manager_add_tick_call (TimeManager *instance, TickCallHandler handler, EventObject *tick_data)
{
	if (instance == NULL)
		return;
	
	instance->AddTickCall (handler, tick_data);
}


int
time_manager_get_maximum_refresh_rate (TimeManager *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetMaximumRefreshRate ();
}


void
time_manager_set_maximum_refresh_rate (TimeManager *instance, int hz)
{
	if (instance == NULL)
		return;
	
	instance->SetMaximumRefreshRate (hz);
}


/**
 * Transform
 **/
Transform *
transform_new (void)
{
	return new Transform ();
}


/**
 * TransformCollection
 **/
TransformCollection *
transform_collection_new (void)
{
	return new TransformCollection ();
}


/**
 * TransformGroup
 **/
TransformGroup *
transform_group_new (void)
{
	return new TransformGroup ();
}


/**
 * TranslateTransform
 **/
TranslateTransform *
translate_transform_new (void)
{
	return new TranslateTransform ();
}


/**
 * TriggerAction
 **/
void
trigger_action_fire (TriggerAction *instance)
{
	if (instance == NULL)
		return;
	
	instance->Fire ();
}


TriggerAction *
trigger_action_new (void)
{
	return new TriggerAction ();
}


/**
 * TriggerActionCollection
 **/
TriggerActionCollection *
trigger_action_collection_new (void)
{
	return new TriggerActionCollection ();
}


/**
 * TriggerBase
 **/
TriggerBase *
trigger_base_new (void)
{
	return new TriggerBase ();
}


/**
 * TriggerCollection
 **/
TriggerCollection *
trigger_collection_new (void)
{
	return new TriggerCollection ();
}


/**
 * Types
 **/
void
types_free (Types *instance)
{
	delete instance;
}


Type *
types_find (Types *instance, Type::Kind type)
{
	if (instance == NULL)
		return NULL;
	
	return instance->Find (type);
}


Type::Kind
types_register_type (Types *instance, const char *name, void *gc_handle, Type::Kind parent)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->RegisterType (name, gc_handle, parent);
}


Types *
types_new (void)
{
	return new Types ();
}


/**
 * UIElement
 **/
void
uielement_arrange (UIElement *instance, Rect finalRect)
{
	if (instance == NULL)
		return;
	
	instance->Arrange (finalRect);
}


bool
uielement_capture_mouse (UIElement *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->CaptureMouse ();
}


void
uielement_element_added (UIElement *instance, UIElement *obj)
{
	if (instance == NULL)
		return;
	
	instance->ElementAdded (obj);
}


void
uielement_element_removed (UIElement *instance, UIElement *obj)
{
	if (instance == NULL)
		return;
	
	instance->ElementRemoved (obj);
}


void
uielement_find_elements_in_host_coordinates_p (UIElement *instance, Point p, HitTestCollection *uielement_list)
{
	if (instance == NULL)
		return;
	
	instance->FindElementsInHostCoordinates_p (p, uielement_list);
}


void
uielement_find_elements_in_host_coordinates_r (UIElement *instance, Rect p, HitTestCollection *uielement_list)
{
	if (instance == NULL)
		return;
	
	instance->FindElementsInHostCoordinates_r (p, uielement_list);
}


Size
uielement_get_desired_size (UIElement *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->GetDesiredSize ();
}


Size
uielement_get_render_size (UIElement *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->GetRenderSize ();
}


DependencyObject *
uielement_get_subtree_object (UIElement *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSubtreeObject ();
}


GeneralTransform *
uielement_get_transform_to_uielement_with_error (UIElement *instance, UIElement *to_element, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called uielement_get_transform_to_uielement_with_error () with error == NULL.");
	return instance->GetTransformToUIElementWithError (to_element, error);
}


UIElement *
uielement_get_visual_parent (UIElement *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetVisualParent ();
}


void
uielement_invalidate_arrange (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->InvalidateArrange ();
}


void
uielement_invalidate_measure (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->InvalidateMeasure ();
}


void
uielement_measure (UIElement *instance, Size availableSize)
{
	if (instance == NULL)
		return;
	
	instance->Measure (availableSize);
}


void
uielement_release_mouse_capture (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->ReleaseMouseCapture ();
}


void
uielement_set_subtree_object (UIElement *instance, DependencyObject *value)
{
	if (instance == NULL)
		return;
	
	instance->SetSubtreeObject (value);
}


bool
uielement_update_layout (UIElement *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->UpdateLayout ();
}


/**
 * UIElementCollection
 **/
UIElementCollection *
uielement_collection_new (void)
{
	return new UIElementCollection ();
}


/**
 * UnmanagedMatrix
 **/
UnmanagedMatrix *
unmanaged_matrix_new (void)
{
	return new UnmanagedMatrix ();
}


/**
 * Uri
 **/
bool
uri_equals (const Uri *left, const Uri *right)
{
	return Uri::Equals (left, right);
}


void
uri_free (Uri *instance)
{
	if (instance == NULL)
		return;
	
	instance->Free ();
}


guint
uri_get_hash_code (Uri *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint) 0;
	
	return instance->GetHashCode ();
}


bool
uri_parse (Uri *instance, const char *uri, bool allow_trailing_sep)
{
	if (instance == NULL)
		return false;
	
	return instance->Parse (uri, allow_trailing_sep);
}


/**
 * UserControl
 **/
UserControl *
user_control_new (void)
{
	return new UserControl ();
}


/**
 * VideoBrush
 **/
void
video_brush_set_source (VideoBrush *instance, MediaElement *source)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (source);
}


VideoBrush *
video_brush_new (void)
{
	return new VideoBrush ();
}


/**
 * VideoStream
 **/
VideoStream *
video_stream_new (Media *media, int codec_id, guint32 width, guint32 height, guint64 duration, gpointer extra_data, guint32 extra_data_size)
{
	return new VideoStream (media, codec_id, width, height, duration, extra_data, extra_data_size);
}


/**
 * VisualBrush
 **/
VisualBrush *
visual_brush_new (void)
{
	return new VisualBrush ();
}


/**
 * WriteableBitmap
 **/
gpointer
writeable_bitmap_initialize_from_bitmap_source (WriteableBitmap *instance, BitmapSource *source)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gpointer) 0;
	
	return instance->InitializeFromBitmapSource (source);
}


void
writeable_bitmap_lock (WriteableBitmap *instance)
{
	if (instance == NULL)
		return;
	
	instance->Lock ();
}


void
writeable_bitmap_render (WriteableBitmap *instance, UIElement *element, Transform *transform)
{
	if (instance == NULL)
		return;
	
	instance->Render (element, transform);
}


void
writeable_bitmap_unlock (WriteableBitmap *instance)
{
	if (instance == NULL)
		return;
	
	instance->Unlock ();
}


WriteableBitmap *
writeable_bitmap_new (void)
{
	return new WriteableBitmap ();
}


/**
 * XamlLoader
 **/
Value *
xaml_loader_create_from_file_with_error (XamlLoader *instance, const char *xaml, bool create_namescope, Type::Kind *element_type, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called xaml_loader_create_from_file_with_error () with error == NULL.");
	return instance->CreateFromFileWithError (xaml, create_namescope, element_type, error);
}


Value *
xaml_loader_create_from_string_with_error (XamlLoader *instance, const char *xaml, bool create_namescope, Type::Kind *element_type, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called xaml_loader_create_from_string_with_error () with error == NULL.");
	return instance->CreateFromStringWithError (xaml, create_namescope, element_type, error);
}


Value *
xaml_loader_hydrate_from_string_with_error (XamlLoader *instance, const char *xaml, DependencyObject *obj, bool create_namescope, Type::Kind *element_type, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called xaml_loader_hydrate_from_string_with_error () with error == NULL.");
	return instance->HydrateFromStringWithError (xaml, obj, create_namescope, element_type, error);
}


/**
 * Xap
 **/
char *
xap_unpack (const char *fname)
{
	return Xap::Unpack (fname);
}


