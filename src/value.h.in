/*
 * value.h: Generated code for the type system.
 *
 * Contact:
 *   Moonlight List (moonlight-list@lists.ximian.com)
 *
 * Copyright 2007 Novell, Inc. (http://www.novell.com)
 *
 * See the LICENSE file included with the distribution for details.
 * 
 */

#ifndef MOON_VALUE_H
#define MOON_VALUE_H

#include <glib.h>
#include <string.h>
#include <stdint.h>
#include <cairo.h>

#include "type.h"

/* 
 * ugly file containing the catchall value type we use.
 */

struct Color;
struct DoubleArray;
struct Duration;
struct KeyTime;
struct Point;
struct PointArray;
struct Rect;
struct Size;
struct RepeatBehavior;
struct GridLength;
struct Thickness;

struct Value;

class Type;
class DependencyProperty;
class Surface;
class AnimationStorage;

/*DO_FWD_DECLS*/

#define checked_get_exact(kind, errval, mem)  g_return_val_if_fail (k == (kind), errval); return mem;
#define checked_get_subclass(kind, castas)  if (u.dependency_object == NULL) return NULL; g_return_val_if_fail (Type::Find((kind))->IsSubclassOf(k) || Type::Find(k)->IsSubclassOf((kind)), NULL); return (castas*)u.dependency_object;

struct Value {
public:
	void Init ();

	Value ();
	Value (const Value& v);
	Value (Type::Kind k);
	Value (bool z);
	Value (double d);
	Value (gint64 i, Type::Kind as); // Use for TimeSpan and int64 values.
	Value (gint32 i);
	Value (Color c);
	Value (EventObject *obj);
	Value (Point pt);
	Value (Rect rect);
	Value (Size size);
	Value (RepeatBehavior repeat);
	Value (Duration duration);
	Value (KeyTime keytime);
	Value (GridLength grid_length);
	Value (Thickness thickness);
	Value (const char *s);
	Value (Point *points, int count);
	Value (double *values, int count);

	~Value ();

	// Use these to create Values with dependency objects with
	// a reference count of 1 (giving the ownership of the object
	// to Value).
	// Useful in cases like this:
	//   SetValue (SomeProperty, new DependencyObject ())
	// in which case we have to unref the newly created object.
	static Value* CreateUnrefPtr (DependencyObject* dob);
	static Value  CreateUnref (DependencyObject* dob);

	bool operator!= (const Value &v) const
	{
		return !(*this == v);
	}

	bool operator== (const Value &v) const
	{
		if (k != v.k)
			return false;

		if (k == Type::STRING) {
			if (u.s == NULL){
				return v.u.s == NULL;
			} else if (v.u.s == NULL)
				return FALSE;

			return !strcmp (u.s, v.u.s);
		}
		else {
			return !memcmp (&u, &v.u, sizeof (u));
		}

		return true;
	}
	
	bool		Is (Type::Kind type) { return Type::IsSubclassOf (k, type); }

	bool		AsBool ()	{ checked_get_exact (Type::BOOL, false, (bool)u.i32); }
	double 		AsDouble ()	{ checked_get_exact (Type::DOUBLE, 0.0, u.d); }
	guint64		AsUint64 ()	{ checked_get_exact (Type::UINT64, 0, u.ui64); }
	gint64		AsInt64 ()	{ checked_get_exact (Type::INT64, 0, u.i64); }
	TimeSpan	AsTimeSpan ()	{ checked_get_exact (Type::TIMESPAN, 0, (TimeSpan)u.i64); }
	gint32		AsInt32 ()	{ checked_get_exact (Type::INT32, 0, u.i32); }
	Color*		AsColor ()	{ checked_get_exact (Type::COLOR, NULL, u.color); }
	Point*		AsPoint ()	{ checked_get_exact (Type::POINT, NULL, u.point); }
	Rect*		AsRect ()	{ checked_get_exact (Type::RECT, NULL, u.rect); }
	Size*		AsSize ()	{ checked_get_exact (Type::SIZE, NULL, u.size); }
	char*		AsString ()	{ checked_get_exact (Type::STRING, NULL, u.s); }
	PointArray*	AsPointArray ()	{ checked_get_exact (Type::POINT_ARRAY, NULL, u.point_array); }
	DoubleArray*	AsDoubleArray ()	{ checked_get_exact (Type::DOUBLE_ARRAY, NULL, u.double_array); }
	
	void *		AsManagedObject () { checked_get_exact (Type::MANAGED, NULL, u.managed_object); }
	
	RepeatBehavior*	AsRepeatBehavior ()	{ checked_get_exact (Type::REPEATBEHAVIOR, NULL, u.repeat); }
	Duration*	AsDuration ()	{ checked_get_exact (Type::DURATION, NULL, u.duration); }
	KeyTime*	AsKeyTime ()	{ checked_get_exact (Type::KEYTIME, NULL, u.keytime); }
	GridLength*     AsGridLength () { checked_get_exact (Type::GRIDLENGTH, NULL, u.grid_length); }
	Thickness*      AsThickness () { checked_get_exact (Type::THICKNESS, NULL, u.thickness); }

	/* nullable primitives (all but bool) */
	double*		AsNullableDouble ()	{ checked_get_exact (Type::DOUBLE, NULL, &u.d); }
	uint64_t*	AsNullableUint64 ()	{ checked_get_exact (Type::UINT64, NULL, &u.ui64); }
	int64_t*	AsNullableInt64 ()	{ checked_get_exact (Type::INT64, NULL, &u.i64); }
	int32_t*	AsNullableInt32 ()	{ checked_get_exact (Type::INT32, NULL, &u.i32); }

/*DO_AS*/

	char *ToString ();

  	Type::Kind GetKind ();

	void FreeValue ();
  
  private:
	Type::Kind k;

	int32_t padding;

	union {
		double d;
		guint64 ui64;
		gint64 i64;
		gint32 i32;
		char *s;
		EventObject *dependency_object;
		Color *color;
		Point *point;
		Rect *rect;
		Size *size;
		RepeatBehavior *repeat;
		Duration *duration;
		KeyTime *keytime;
		PointArray *point_array;
		DoubleArray *double_array;
		GridLength *grid_length;
		Thickness *thickness;
		void *managed_object;
	} u;


	// You don't want to be using this ctor.  it's here to help
	// c++ recognize bad unspecified pointer args to Value ctors
	// (it normally converts them to bool, which we handle, so you
	// never see the error of your ways).  So do the world a
	// favor, and don't expose this ctor. :)
	Value (void* v) { }
	// You don't want to be using this ctor either.
	// Use the Value (gint64, Type::Kind) ctor
	// (Both for TimeSpan and int64_t)
	// This one is bad because it get used by either int64_t
	// and TimeSpan, and the constructor doesn't know which 
	// of the two types it is.
	Value (gint64 i) {};
};

G_BEGIN_DECLS
void value_free_value (Value *value);
G_END_DECLS


#endif /* MOON_VALUE_H */
