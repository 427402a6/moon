/*
 * type.cpp: Generated code for the type system.
 *
 * Author:
 *   Rolf Bjarne Kvinge (RKvinge@novell.com)
 *
 * Copyright 2007 Novell, Inc. (http://www.novell.com)
 *
 * See the LICENSE file included with the distribution for details.
 * 
 */

#include <config.h>
#include <string.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <malloc.h>
#include <stdlib.h>
#include "type.h"

/*
	Type implementation
*/

Type** Type::types = NULL;
GHashTable* Type::types_by_name = NULL;

Type::Type (const char *name, Type::Kind type, Type::Kind parent)
{
	this->name = strdup (name);
	this->type = type;
	this->parent = parent;

	local_event_count = 0;
	local_event_base = -1;
	type_event_count = -1;
	event_name_hash = NULL;
}

Type::~Type()
{
	if (event_name_hash) {
		g_hash_table_foreach (event_name_hash, (GHFunc)g_free, NULL);
		g_hash_table_destroy (event_name_hash);
	}

	event_name_hash = NULL;

	free (name);
}

void
Type::RegisterEvent (const char *event_name)
{
	if (event_name_hash == NULL)
		event_name_hash = g_hash_table_new (g_str_hash, g_str_equal);

	g_hash_table_insert (event_name_hash, g_strdup (event_name), GINT_TO_POINTER (local_event_count++));
}

int
Type::LookupEvent (const char *event_name)
{
	gpointer key, value;
	if (event_name_hash &&
	    g_hash_table_lookup_extended (event_name_hash,
					  event_name,
					  &key,
					  &value)) {

		return GPOINTER_TO_INT (value) + GetEventBase();
	}
	
	if (parent == Type::INVALID) {
		printf ("type lookup of event '%s' failed\n", event_name);
		return -1;
	}
	else {
		return Type::Find (parent)->LookupEvent (event_name);
	}
}

int
Type::GetEventBase ()
{
	if (local_event_base == -1) {
		if (parent == Type::INVALID)
			local_event_base = 0;
		else
			local_event_base = Type::Find(parent)->GetEventCount();
	}

	return local_event_base;
}

int
Type::GetEventCount ()
{
	if (type_event_count == -1)
		type_event_count = GetEventBase() + local_event_count;

	return type_event_count;
}

Type *
Type::RegisterType (const char *name, Type::Kind type, bool value_type)
{
	return RegisterType (name, type, Type::INVALID, value_type);
}

void
Type::free_type (gpointer type)
{
	delete (Type*)type;
}

Type *
Type::RegisterType (const char *name, Type::Kind type, Type::Kind parent)
{
	return RegisterType (name, type, parent, false);
}

Type *
Type::RegisterType (const char *name, Type::Kind type, Type::Kind parent, bool value_type)
{
	if (types == NULL) {
		types = (Type**)calloc (Type::LASTTYPE, sizeof (Type*));
	}
	if (types_by_name == NULL) {
		types_by_name = g_hash_table_new_full (g_str_hash, g_str_equal,
						       NULL, free_type);
	}

	Type *result = new Type (name, type, parent);
	result->value_type = value_type;

	g_assert (types [type] == NULL);

	types [type] = result;
	g_hash_table_insert (types_by_name, result->name, result);

	return result;
}

bool 
Type::IsSubclassOf (Type::Kind super)
{
	if (type == super)
		return true;

	if (parent == super)
		return true;

	if (parent == Type::INVALID)
		return false;

	Type *parent_type = Find (parent);
	
	if (parent_type == NULL)
		return false;
	
	return parent_type->IsSubclassOf (super);
}

Type *
Type::Find (const char *name)
{
	Type *result;

	if (types_by_name == NULL)
		return NULL;

	result = (Type*) g_hash_table_lookup (types_by_name, name);

	return result;
}

Type *
Type::Find (Type::Kind type)
{
	return types [type];
}

void
Type::Shutdown ()
{
	if (types) {
		g_free (types);
		types = NULL;
	}
	if (types_by_name) {
		g_hash_table_destroy (types_by_name);
		types_by_name = NULL;
	}
}

bool
type_get_value_type (Type::Kind type)
{
	return Type::Find (type)->value_type;
}

static void 
types_init_manually (void)
{
	// Put types that does not inherit from DependencyObject here (manually)

	//Type::RegisterType ("Invalid", Type::INVALID, Value::INVALID);
	Type::RegisterType ("bool", Type::BOOL, true);
	Type::RegisterType ("double", Type::DOUBLE, true);
	Type::RegisterType ("uint64", Type::UINT64, true);
	Type::RegisterType ("int", Type::INT32, true);
	Type::RegisterType ("string", Type::STRING, false);
	Type::RegisterType ("Color", Type::COLOR, true);
	Type::RegisterType ("Point", Type::POINT, true);
	Type::RegisterType ("Rect", Type::RECT, true);
	Type::RegisterType ("RepeatBehaviour", Type::REPEATBEHAVIOR, true);
	Type::RegisterType ("Duration", Type::DURATION, true);
	Type::RegisterType ("int64", Type::INT64, true);
	Type::RegisterType ("TimeSpan", Type::TIMESPAN, true);
	Type::RegisterType ("KeyTime", Type::KEYTIME, true);
	Type::RegisterType ("double*", Type::DOUBLE_ARRAY, false);
	Type::RegisterType ("Point*", Type::POINT_ARRAY, false);
	Type::RegisterType ("Matrix", Type::MATRIX, true);
	Type::RegisterType ("NPObj", Type::NPOBJ, false);
	Type::RegisterType ("Base", Type::BASE, false);
	Type::RegisterType ("EventObject", Type::EVENTOBJECT, Type::BASE);
	Type::RegisterType ("TimeManager", Type::TIMEMANAGER, Type::EVENTOBJECT);
	Type::RegisterType ("Surface", Type::SURFACE, Type::EVENTOBJECT);
#if DEBUG
	for (int i = 1; i < Type::LASTTYPE; i++) {
		if (Type::types [i] != NULL)
			continue;

		if (i > 0 && Type::types [i - 1] != NULL)
			printf ("Type %i is not initialized (previous type in enum is '%s')\n", i, Type::types [i - 1]->name);
		else
			printf ("Type %i is not initialized\n", i);
	}
#endif
}

static void 
types_init_register_events (void)
{
	Type* t;

	t = Type::Find (Type::EVENTOBJECT);
	t->RegisterEvent ("Destroyed");

	t = Type::Find (Type::STORYBOARD);
	t->RegisterEvent ("Completed");

	t = Type::Find (Type::TIMEMANAGER);
	t->RegisterEvent ("update-input");
	t->RegisterEvent ("render");

	t = Type::Find (Type::CLOCK);
	t->RegisterEvent ("CurrentTimeInvalidated");
	t->RegisterEvent ("CurrentStateInvalidated");
	t->RegisterEvent ("CurrentGlobalSpeedInvalidated");
	t->RegisterEvent ("Completed");

	t = Type::Find (Type::DOWNLOADER);
	t->RegisterEvent ("Completed");
	t->RegisterEvent ("DownloadProgressChanged");
	t->RegisterEvent ("DownloadFailed");

	t = Type::Find (Type::MEDIAELEMENT);
	t->RegisterEvent ("BufferingProgressChanged");
	t->RegisterEvent ("CurrentStateChanged");
	t->RegisterEvent ("DownloadProgressChanged");
	t->RegisterEvent ("MarkerReached");
	t->RegisterEvent ("MediaEnded");
	t->RegisterEvent ("MediaFailed");
	t->RegisterEvent ("MediaOpened");

	t = Type::Find (Type::IMAGE);
	t->RegisterEvent ("ImageFailed");

	t = Type::Find(Type::SURFACE);
	t->RegisterEvent ("Resize");
	t->RegisterEvent ("FullScreenChange");

	t = Type::Find(Type::UIELEMENT);
	t->RegisterEvent ("Loaded");
	t->RegisterEvent ("MouseMove");
	t->RegisterEvent ("MouseLeftButtonDown");
	t->RegisterEvent ("MouseLeftButtonUp");
	t->RegisterEvent ("KeyDown");
	t->RegisterEvent ("KeyUp");
	t->RegisterEvent ("MouseEnter");
	t->RegisterEvent ("MouseLeave");
	t->RegisterEvent ("Invalidated");
	t->RegisterEvent ("GotFocus");
	t->RegisterEvent ("LostFocus");
}

//
// The generated code will be put at the end of the file
//
// We are currently generating:
//	- types_init (), initializes all types that inherit from DependencyObject

