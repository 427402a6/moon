
Feel free to add items to this TODO list

* Managed Code:

	Write sample code to exercise every property.

* UIElement

	Need to add support for events:

	Event: Loaded
		This probably should be used instead of the current
		hack that we have, lookup what the semantics for it
		are.

	Events that require hit-testing of some form:

		MouseEnter/MouseLeave/MouseMove/MoustButton

	Events: Focus

		Have to investigate what it means to get "focus"
		with UIElements, there are two signals, GotFocus
		and LostFocus, but what do they mean?

* Video Player:

	Add support for seeking, stopping, shutdown.

	Fix the memory leak that it currently has that brings the 
	system down.

	Should use a depenedency property for its source.

* Reference counting and destruction

	Need to properly shut down the runtime.

	Need managed runtime to:

		* Take a ref on creation (to sink the object)
		* Finalizer, to queue unrefs like Gtk#
		* Something to release the queued refs

		* Use SafeFileHandle to prevent queueing of
	  	  a destruction when we pass an object to unmanaged
		  land during a P/Invoke

* XAML Support

	Add support to each element to be created from a xaml string.

* XAML, the revenge of namespaces:

    Consider this:
                        
                        <Chess:BoardUI
                          xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                          xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                          Width="640" Height="480"   Background="black"
                          xmlns:Chess="clr-namespace:Chess;assembly=ClientBin/Chess.dll"
                          Loaded="Canvas_Loaded">

     It should parse the above, and notice that the Chess NS is
introduce in that declaration.   What is interesting though is that it
uses requests an assembly to download there.

* XAML, callbacks during initial construction

	When the code above notices the "assembly" stuff, it should call
	back a routine so we can provide the UIElement that will be created.
	
	In this case, we will have the browser download the stuff, instantiate
	the object in managed land, and return the object.


* Paths

	Sam Ruby had some path tests, we could use that as test cases.
	http://intertwingly.net/stories/2007/05/06/

* Shapes

	All shapes must implement the ::getxformorigin method, the metho
	is used to determine the center of the object.

* Color

	Right now the unmanaged side use 4 doubles for colors (ARGB), 
	while the managed side use an uint (4 bytes) and must also give
	float (not double) representations (ScA, ScR, ScG & ScB). All 
	this will eventually need to be merged into a single 
	representation

* Managed side

	UIElement.cs currently uses standard events, it should instead
	use something like EventList like Windows.Forms does to avoid
	wasting all that space on all those fields that are barely used.

	Also, it should probably flag when the frist event is set to
	avoid having the native code send any events when we are not
	interested in them.

	Something like on "add" we would do:

		NativeMethods.UIElement_register_interest_in_events (...)

* Canvas/Surface

	The canvas currently is set to width/height = 0 (we never initialize it),
	but the surface should actually track the size of the canvas.

	This leads to code in Canvas::handle_motion that does not work
	for now (since we are an object with no size).

* Video Brush

	Figure out how to use the video code to use as a brush.

* Mouse

	Implement mouse grabs


* Gtk Hackery

	For some reason I cant get moon/test/demo.exe program to focus the
	Silverlight widget even if I click on it and I do a
	gtk_widget_grab_focus, am probably missing something.
	
