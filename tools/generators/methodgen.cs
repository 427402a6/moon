/*
 * methodgen.cs: Code generator for the managed pinvokes
 *
 * Contact:
 *   Moonlight List (moonlight-list@lists.ximian.com)
 *
 * Copyright 2008 Novell, Inc. (http://www.novell.com)
 *
 * See the LICENSE file included with the distribution for details.
 * 
 */
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using Generation;
using Generation.C;

class Generator
{
	string NativeMethods_cs;
	
	public bool IsManuallyDefined (string method)
	{
		if (NativeMethods_cs.Contains (" " + method + " "))
			return true;
		else if (NativeMethods_cs.Contains (" " + method + "("))
			return true;
		else if (NativeMethods_cs.Contains ("\"" + method + "\""))
			return true;
		else
			return false;
	}
	
	public void Generate ()
	{
		string base_dir = Environment.CurrentDirectory;
		string plugin_dir = Path.Combine (base_dir, "plugin");
		string moon_dir = Path.Combine (base_dir, "src");
		List <MethodDefinition> plugin_methods = new List<MethodDefinition> ();
		List <MethodDefinition> moon_methods = new List<MethodDefinition> ();
		StringBuilder text = new StringBuilder ();
		
		if (!Directory.Exists (plugin_dir))
			throw new ArgumentException (string.Format ("methodgen must be executed from the base directory of the moon module ({0} does not exist).", plugin_dir));
		
		if (!Directory.Exists (moon_dir))
			throw new ArgumentException (string.Format ("methodgen must be executed from the base directory of the moon module ({0} does not exist).", moon_dir));
		
		NativeMethods_cs = File.ReadAllText (Path.Combine (base_dir, "class/Mono.Moonlight/Mono/NativeMethods.cs".Replace ('/', Path.DirectorySeparatorChar)));
		
		GetGeneratedMethods (plugin_dir, plugin_methods);
		GetGeneratedMethods (moon_dir, moon_methods);
		
		
		text.AppendLine ("/* \n\tthis file was autogenerated. do not edit this file \n */\n");
		text.AppendLine ("using System;");
		text.AppendLine ("using System.Runtime.InteropServices;");
		text.AppendLine ("");
		text.AppendLine ("namespace Mono {");
		text.AppendLine ("\tpublic static partial class NativeMethods");
		text.AppendLine ("\t{");
		text.AppendLine ("\t\t/* moonplugin methods */");
		text.AppendLine ("\t");
		foreach (MethodDefinition method in plugin_methods) {
			WriteMethod (method, text, "moonplugin");
			text.AppendLine ();
		}
		
		text.AppendLine ("\t");
		text.AppendLine ("\t\t/* libmoon methods */");
		text.AppendLine ("\t");
		foreach (MethodDefinition method in moon_methods) {
			WriteMethod (method, text, "moon");
			text.AppendLine ();
		}
		text.AppendLine ("\t}");
		text.AppendLine ("}");
		
		Helper.WriteAllText (Path.Combine (base_dir, "class/Mono.Moonlight/Mono/GeneratedPInvokes.cs".Replace ('/', Path.DirectorySeparatorChar)), text.ToString ());
	}
	
	void WriteMethod (MethodDefinition method, StringBuilder text, string library)
	{
		WrapperGenerator wrapper_generator = method.GetMarshaller ();
		bool generate_wrapper = wrapper_generator != null;
		string name = method.name;
		string managed_name = (generate_wrapper && name.Contains ("_with_error")) ? name.Replace ("_with_error", "") : name;
		string native_signature = method.signature;
		TypeDefinition returntype = method.returntype;
		bool is_defined = IsManuallyDefined (managed_name);
		bool contains_unknown_types = method.ContainsUnknownTypes;
		bool comment_out = is_defined || contains_unknown_types;
		bool generate_surface_call = false;
		bool is_static = method.returntype.Native == "void";
		string tabs = comment_out ? "\t\t// " : "\t\t";
		
		
		int surface_param = is_static ? 0 : 1;
		if (generate_wrapper && method.parameters.Count > surface_param && method.parameters [surface_param].name == "surface" && method.parameters [surface_param].type.Native == "Surface*") {
			generate_surface_call = true;
		}
		
		if (is_defined)
			text.AppendLine ("\t\t// This method is already defined manually in NativeMethods.cs. Remove the import from there, and regenerate.");
		if (contains_unknown_types) {
			text.AppendLine ("\t\t// This method contains types the generator didn't know about. Fix the generator (find the method 'GetManagedType' in common.cs and add the missing case) and try again.");
		}
			
		text.Append (tabs);
		
		text.Append ("[DllImport (\"");
		text.Append (library);
		if (generate_wrapper) {
			text.Append ("\", EntryPoint=\"");
			text.Append (name);
		}
		text.AppendLine ("\")]");
		
		text.Append ("\t\t// ");
		text.AppendLine (native_signature);
		
		text.Append (tabs);
		
		if (generate_wrapper)
			text.Append ("private ");
		else
			text.Append ("public ");

		text.Append ("extern static ");
		returntype.Write (text, TypeDefinitionType.PInvoke);
		text.Append (" ");
		text.Append (name);
		if (generate_wrapper)
			text.Append ("_");
		method.WriteParameters (text, TypeDefinitionType.PInvoke);
		text.AppendLine (";");
		
		if (generate_wrapper) {
			text.Append (tabs);
			text.Append ("public static ");
			returntype.Write (text, TypeDefinitionType.Managed);
			text.Append (" ");
			text.Append (managed_name);
			if (generate_surface_call) {
				method.parameters [surface_param].disabled_once = true;
				method.parameters [surface_param].managed_wrapper_code = "Mono.Xaml.XamlLoader.SurfaceInDomain";
			}
			method.WriteParameters (text, TypeDefinitionType.Managed);
			text.AppendLine ();
			
			text.Append (tabs);
			text.Append ("{");
			text.AppendLine ();
			
			wrapper_generator (text, tabs);
			
			text.Append (tabs);
			text.Append ("}");
			text.AppendLine ();
		}
	}
	
	void GetGeneratedMethods (string directory, List<MethodDefinition> methods)
	{
		string magic = "/* @GenerateManaged */";
		bool next = false;
		foreach (string file in Directory.GetFiles (directory, "*.h")) {
			foreach (string l in File.ReadAllLines (file)) {
				int comment;
				string line = l;
				if (next) {
					next = false;
					line = line.Replace (magic, string.Empty);
					comment = line.IndexOf ("//");
					if (comment >= 0)
						line = line.Substring (0, comment);
					methods.Add (new MethodDefinition (this, line.Trim ().Replace ("  ", " "), file));
				} else if (line.Contains (magic)) {
					next = true;
				}
				
			}
		}
	}
}
