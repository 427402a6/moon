/*
 * cgen.cs: Code generator for the c bindings
 *
 * Contact:
 *   Moonlight List (moonlight-list@lists.ximian.com)
 *
 * Copyright 2008 Novell, Inc. (http://www.novell.com)
 *
 * See the LICENSE file included with the distribution for details.
 * 
 */
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using Generation;
using Generation.C;

class Generator
{
	public void Generate ()
	{
		string base_dir = Environment.CurrentDirectory;
		string plugin_dir = Path.Combine (base_dir, "plugin");
		string moon_dir = Path.Combine (base_dir, "src");
		List <MethodDefinition> plugin_methods = new List<MethodDefinition> ();
		List <MethodDefinition> moon_methods = new List<MethodDefinition> ();
		StringBuilder header = new StringBuilder ();
		StringBuilder impl = new StringBuilder ();
		List <string> headers = new List<string> ();
		string last_type = string.Empty;
		
		if (!Directory.Exists (plugin_dir))
			throw new ArgumentException (string.Format ("cgen must be executed from the base directory of the moon module ({0} does not exist).", plugin_dir));
		
		if (!Directory.Exists (moon_dir))
			throw new ArgumentException (string.Format ("methodgen must be executed from the base directory of the moon module ({0} does not exist).", moon_dir));
		
		GetGeneratedMethods (moon_dir, moon_methods);
		
		foreach (MethodDefinition method in moon_methods) {
			if (string.IsNullOrEmpty (method.header))
				continue;
			string h = Path.GetFileName (method.header);
			if (!headers.Contains (h))
				headers.Add (h);
		}
		
		header.AppendLine ("/* \n\tthis file was autogenerated. do not edit this file \n */\n");
		impl.AppendLine ("/* \n\tthis file was autogenerated. do not edit this file \n */\n");
		
		header.AppendLine ("#ifndef __MOONLIGHT_C_BINDING_H__");
		header.AppendLine ("#define __MOONLIGHT_C_BINDING_H__");
		header.AppendLine ("");
		header.AppendLine ("#include <glib.h>");
		foreach (string h in headers) {
			header.Append ("#include \"");
			header.Append (h);
			header.AppendLine ("\"");
		}
		header.AppendLine ();
		header.AppendLine ("G_BEGIN_DECLS");
		header.AppendLine ();
		
		impl.AppendLine ("#include \"config.h\"");
		impl.AppendLine ();
		impl.AppendLine ("#include <stdlib.h>");
		impl.AppendLine ("#include <stdio.h>");
		impl.AppendLine ();
		impl.AppendLine ("#include \"cbinding.h\"");
		
		foreach (MethodDefinition method in moon_methods) {
			if (last_type != method.declaringtype) {
				last_type = method.declaringtype;
				foreach (StringBuilder text in new StringBuilder [] {header, impl}) {
					text.AppendLine ("");
					text.AppendLine ("/* ");
					text.Append (" * ");
					text.AppendLine (last_type);
					text.AppendLine (" */ ");
					text.AppendLine ("");
				}
			}
			
			if (!method.is_static && method.name != method.declaringtype) {
				ParameterDefinition parameter = new ParameterDefinition (method, "instance", new TypeDefinition ());
				parameter.type.Native = method.declaringtype + "*";
				method.parameters.Insert (0, parameter);
			}
			
			WriteHeaderMethod (method, header);
			WriteImplMethod (method, impl);
		}
		
		header.AppendLine ();
		header.AppendLine ("G_END_DECLS");
		header.AppendLine ();
		header.AppendLine ("#endif");
		
		Helper.WriteAllText (Path.Combine (moon_dir, "cbinding.h"), header.ToString ());
		Helper.WriteAllText (Path.Combine (moon_dir, "cbinding.cpp"), impl.ToString ());
	}
	
	void WriteMethodIfVersion (MethodDefinition method, StringBuilder text, bool end)
	{
		if (method.properties.ContainsKey ("Version")) {
			if (!end) {
				text.Append ("#if SL_");
				text.AppendLine (((string) method.properties ["Version"]).Replace ('.', '_'));
			} else {
				text.AppendLine ("#endif");
			}
		}
	}
	
	void WriteHeaderMethod (MethodDefinition method, StringBuilder text)	
	{
		Log.WriteLine ("Writing header: {0}::{1} (Version: {2}, GenerateManaged: {3})", 
		               method.declaringtype, method.name, 
		               method.properties.ContainsKey ("Version") ? method.properties ["Version"] : "none",
		               method.properties.ContainsKey ("GenerateManaged") ? method.properties ["GenerateManaged"] : "none");
		WriteMethodIfVersion (method, text, false);
		if (method.properties.ContainsKey ("GenerateManaged") && (bool) method.properties ["GenerateManaged"])
			text.AppendLine ("/* @GenerateManaged */");
		method.returntype.Write (text, TypeDefinitionType.Native);
		text.Append (" ");
		text.Append (CppToCName (method.declaringtype, method.name));
		method.WriteParameters (text, TypeDefinitionType.Native);
		text.AppendLine (";");
		WriteMethodIfVersion (method, text, true);
	}
	
	void WriteImplMethod (MethodDefinition method, StringBuilder text)
	{
		WriteMethodIfVersion (method, text, false);
		bool is_void = method.returntype.Native == "void";
		bool is_ctor = method.name == method.declaringtype;
		bool is_static = method.is_static || is_ctor;
		bool is_dtor = method.name.StartsWith ("~");
		string c_name = CppToCName (method.declaringtype, method.name);
		
		method.returntype.Write (text, TypeDefinitionType.Native);
		text.AppendLine ();
		text.Append (c_name);
		method.WriteParameters (text, TypeDefinitionType.Native);
		text.AppendLine ("");
		text.AppendLine ("{");
		
		if (is_ctor) {
			text.Append ("\treturn new ");
			text.Append (method.declaringtype);
			method.WriteWrapperCall (text, TypeDefinitionType.Native);
			text.AppendLine (";");
		} else if (is_dtor) {
			text.AppendLine ("\tdelete instance;");
		} else {
			if (!is_static) {
				text.AppendLine ("\tif (instance == NULL) {");
				
				if (method.returntype.Native.Contains ("*")) {	
					text.Append ("\t\treturn");
					if (!is_void)
						text.Append (" NULL");
				} else {
					text.AppendLine ("\t\t// Need to find a property way to get the default value for the specified type and return that if instance is NULL.");
					text.Append ("\t\treturn");
					text.Append (" (");
					text.Append (method.returntype.Native);
					text.Append (") 0");
				}
				text.AppendLine (";");
				
				text.AppendLine ("\t}");
			}
			
			if (method.parameters.Count > 0 && method.parameters [method.parameters.Count - 1].type.Native == "MoonError*") {
				text.AppendLine ("\tif (error == NULL)");
				text.Append ("\t\tg_warning (\"Moonlight: Called ");
				text.Append (c_name);
				text.AppendLine (" () with error == NULL.\");");
			}
			
			text.Append ("\t");
			if (!is_void)
				text.Append ("return ");
			
			
			if (is_static) {
				text.Append (method.declaringtype);
				text.Append ("::");
			} else {
				text.Append ("instance->");
				method.parameters [0].disabled_once = true;
			}
			text.Append (method.name);
			method.WriteWrapperCall (text, TypeDefinitionType.Native);
			text.AppendLine (";");
		} 
			
		text.AppendLine ("}");
		WriteMethodIfVersion (method, text, true);
		text.AppendLine ();
	}
	
	StringBuilder MakeCLowerCase (string name)
	{
		StringBuilder result = new StringBuilder (name.Length + 5);
		for (int i = 0; i < name.Length; i++) {
			if (char.IsUpper (name [i])) {
				if (i > 0)
					result.Append ("_");
				result.Append (char.ToLower (name [i]));
			} else {
				result.Append (name [i]);
			}
		}
		return result;
	}
	
	string CppToCName (string type, string name)
	{
		StringBuilder result = new StringBuilder (name.Length + type.Length + 5);
		
		result.Append (MakeCLowerCase (type));
		result.Append ("_");
		if (type == name) {
			result.Append ("new");
		} else if (name.StartsWith ("~")) {
			result.Append ("free");
		} else {
			result.Append (MakeCLowerCase (name));
		}
		
		return result.ToString ();
	}
	
	void GetGeneratedMethods (string directory, List<MethodDefinition> methods)
	{
		MethodDefinition def;
		string magic = "/* @GenerateCBinding";
		bool next = false;
		string tmp;
		string type = null;
		Dictionary <string, object> magic_arguments = new Dictionary<string,object> ();
		
		foreach (string file in Directory.GetFiles (directory, "*.h")) {
			foreach (string l in File.ReadAllLines (file)) {
				int comment;
				string line = l;
				if (next) {
					next = false;
					line = line.Replace (magic, string.Empty);
					comment = line.IndexOf ("//");
					if (comment >= 0)
						line = line.Substring (0, comment);
					def = new MethodDefinition (this, line.Trim ().Replace ("  ", " "), file);
					def.declaringtype = type;
					
					foreach (System.Collections.Generic.KeyValuePair <string, object> pair in magic_arguments)
						def.properties.Add (pair.Key, pair.Value);
					
					def.header = file;
					def.Dump ();
					methods.Add (def);
					//Console.WriteLine ("Found method: {0}::{1}", def.declaringtype, def.name);
				} else if (line.Contains (magic)) {
					next = true;
					tmp = line.Substring (line.IndexOf (magic) + magic.Length +1 );
					tmp = tmp.Substring (0, tmp.IndexOf ("*/")).Trim ();
					magic_arguments = ParseArguments (tmp);
					if (!magic_arguments.ContainsKey ("Type"))
						throw new ArgumentException ("Magic comment must contain a Type=<Type> (something like: " + magic + ":Type=DependencyProperty */)");
					type = (string) magic_arguments ["Type"];
				}
			}
		}
	}
	
	Dictionary <string, object> ParseArguments (string args)
	{
		Dictionary <string, object> result = new Dictionary<string,object> ();
		
		foreach (string pair in args.Split (new char [] {','}, StringSplitOptions.RemoveEmptyEntries)) {
			string [] v = pair.Split ('=');
			if (v.Length != 2)
				throw new Exception (string.Format ("Invalid magic argument: '{0}', it must be of the format: key1=value1,key2=value2", pair));
			if (v [1] == "true") {
				result.Add (v [0], true);
			} else if (v [1] == "false") {
				result.Add (v [0], false);
			} else {
				result.Add (v [0], v [1]);
			}
			//Console.WriteLine ("Got argument: '{0}' = '{1}'", v [0], v [1]);
		}
		return result;
	}
}