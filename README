This contains a minimal runtime in C for trying out some ideas for the
Moonlight binding.   It is not designed to be our final implementation. 

The C++ file here was merely to test Agg, but the public API is pure C
and without agg (which is currently disabled due to laziness on my
part) it should build with a C compiler

This is not likely the final version of this code.

* Use of C++

	C++ is only used for the class hierarchy and API entry points
	are not exposed as C++ member methods but instead they are exposed
	as regular C-callable methods that have access to the C++
	public fields or any other public inline declarations.

	Object creation uses the gtk-like naming scheme for constructors:

		ClassName *class_name_new ();

	Destruction of these objects is also done in the C-like way:

		class_name_destroy (ClassName *object)

	This is done so that our public API can be easily P/Invoked
	from the managed side. 

* Base and Reference Counting

	Base objects use a system similar to Gtk's object reference
	counting.  Objets are born in "floating" mode, which when
	first refed turn into "refcount = 1".

	This allows code like this:

		shape_set_brush (rect, new SolidBrush ());

	Without having to manually decrement the reference count for 
	the SolidBrush immediately following it.

	When an object is exposed to the managed world, it must be
	referenced.

* Items

	Items for the base class for all the objects that are rendered,
	items contain a bounding box (double x1, y1, x2, y2) which must
	be updated when the virtual method ->getbounds is called.

	In addition each item can contain an affine transformation,
	the code tracks the user set values as well as an absolute
	affine transformation.
	
	The encoding of the affine transformation is done with a
	"double *" which, if not-NULL should point to six doubles in 
	the format expected by cairo_matrix_t (and libart).

	The double [6] can be casted into a cairo_matrix_t, which is why
	this appers like that in the source code.  This was done in
	case we want to switch to AGG.

* Class Hierarchy

	I tried to simplify the class hierarchy from the one found in:

		www.mono-project.com/WPFNotes

	We will likely have to introudce some of the same classes to mirror
	the hierarchy as my over-simplification left a few things out.

* Lighter objects

	Currently the code stores all the properties in the classes,
	this needs to be changed to use a DependencyProperty-like system,
	which basically makes objects lightweight.

	All objects basically have a hashtable:

		Hashtable properties;

	And properties become for example:

		static default_value_for_x;

		object_get_x ()
		{
			if (properties.Contains ("x"))
				return properties ["x"];
			else
				return default_value_for_x;
		}

	This ensures that objects with a few hundred exposed
	properties (that are barely changed) do not consume a lot of memory.

* Rendering in Items

	Rendering currently passes the parent affine, but it might be possible to
	avoid this if we end up using Cairo: just use the affine that is part of 
	the cairo context at the time of the rendering.

* Video

	The video stuff is *incredibly* early at this point and
	requires an FFmpeg installation from SVN (the only available
	one). 

	Currently this is very basic, it merely does video frame decoding, and
	makes no attempt to keep track of the clock (as it should) nor to do any
	kind of audio output (yet).

	The video is also busted, I do not know why, but the "decoded"
	video is incorrect, it has the wrong colors.

	The video thread currently sends "messages" to the main thread
	to do two things: 

		* To inform the main thread that the video has been
		  initialized and that the video bounds can be computed.

		* To request an invalidate (when a new frame is ready)

	The invalidate request could *perhaps* be done by taking the
	Gdk lock and issuing the invalidate directly.

	The issue is that we might need to lock also on the
	(Item *) structures in case the user-code is making changes to the
	affine transform and hence the bounding box as we are trying
	to access those from the Gdk lock. 

* Rendering

	Currently we are creating a bitmap surface and we always copy
	it to the screen.  This approach is fine for non-compositing
	managers as this serves as our double-buffering primitive.

	David Reveman has some suggestions for the future:

		* We could create an xlib surface for the backing
		  store of the videos, this would help if we need
		  later to do video rendering in a separate process
		  or thread (for the compiz integration).

		* With a compositing manager we could use the xlib	
		  surface as this would properly synchornize and 
	 	  not require the client side double buffering. 

* Expose

	Currently repaints happen with an item_invalidate, I need to
	research if this clears the background before repainting.

* Usage of C++

	I do not know how to initialize instance fields in a structure
	with the contructor, so there is code like this:

	    struct {
		Agg2D *graphics;
	    }

	Then:

		something->graphics = new Agg2D ()

	Followed by uses of graphics in that way, there is probably a
	better way.

* Demo

	The demo has a couple of hardcoded videos for now, you must
	edit the filenames hardcoded inside of it.

	Sometimes you might also have to define VIDEO_DEMO at the top,
	as every once in a while I will disable them.

	There is currently a race condition in the rendering engine,
	I have not yet been able to find out what it is, so sometimes
	the engine will not display anything, restart it in those cases.

	You will notice some rectangles painting, thats where the
	video should be, it is also not clear why those move

* Debugging

	It is recommended that for now you do not `make install' as there
	is not much to use.

	To debug, use:

		cd src

		make debug
