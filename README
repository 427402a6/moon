This contains a minimal runtime in C for trying out some ideas for the
Moonlight binding.   It is not designed to be our final implementation. 

The C++ file here was merely to test Agg, but the public API is pure C
and without agg (which is currently disabled due to laziness on my
part) it should build with a C compiler

This is not likely the final version of this code.

* Dependencies

	ffmpeg, from:

		svn://svn.mplayerhq.hu/ffmpeg/trunk
		Revision: 9167 is known to work

		svn co -r 9167 svn://svn.mplayerhq.hu/ffmpeg/trunk ffmpeg

		Then configure/make/make install

	alsa-devel
		For Audio

	
* Use of C++

	C++ is only used for the class hierarchy and API entry points
	are not exposed as C++ member methods but instead they are exposed
	as regular C-callable methods that have access to the C++
	public fields or any other public inline declarations.

	Object creation uses the gtk-like naming scheme for constructors:

		ClassName *class_name_new ();

	Destruction of these objects is also done in the C-like way:

		class_name_destroy (ClassName *object)

	This is done so that our public API can be easily P/Invoked
	from the managed side. 

	Notice that the majority of property setters and getters for
	DependencyProperties will be done through two calls:

		dependency_object_set_value
		dependency_object_get_value

	So there is no need to bind much more than that for
	getting/setting, unless those setting/getting are useful to
	develop/debug the C++ code.

* Base and Reference Counting

	Base objects use a system similar to Gtk's object reference
	counting.  Objets are born in "floating" mode, which when
	first refed turn into "refcount = 1".

	This allows code like this:

		shape_set_brush (rect, new SolidBrush ());

	Without having to manually decrement the reference count for 
	the SolidBrush immediately following it.

	When an object is exposed to the managed world, it must be
	referenced.

* Items

	Items for the base class for all the objects that are rendered,
	items contain a bounding box (double x1, y1, x2, y2) which must
	be updated when the virtual method ->getbounds is called.

	In addition each item can contain an affine transformation,
	the code tracks the user set values as well as an absolute
	affine transformation.
	
	The encoding of the affine transformation is done with a
	"double *" which, if not-NULL should point to six doubles in 
	the format expected by cairo_matrix_t (and libart).

	The double [6] can be casted into a cairo_matrix_t, which is why
	this appers like that in the source code.  This was done in
	case we want to switch to AGG.

* Class Hierarchy

	I tried to simplify the class hierarchy from the one found in:

		www.mono-project.com/WPFNotes

	We will likely have to introudce some of the same classes to mirror
	the hierarchy as my over-simplification left a few things out.

* Lighter objects

	Currently the code stores all the properties in the classes,
	this needs to be changed to use a DependencyProperty-like system,
	which basically makes objects lightweight.

	All objects basically have a hashtable:

		Hashtable properties;

	And properties become for example:

		static default_value_for_x;

		object_get_x ()
		{
			if (properties.Contains ("x"))
				return properties ["x"];
			else
				return default_value_for_x;
		}

	This ensures that objects with a few hundred exposed
	properties (that are barely changed) do not consume a lot of memory.

* Rendering in Items

	Rendering currently passes the parent affine, but it might be possible to
	avoid this if we end up using Cairo: just use the affine that is part of 
	the cairo context at the time of the rendering.

* Video

	The video stuff is *incredibly* early at this point and
	requires an FFmpeg installation from SVN (the only available
	one). 

	Currently this is very basic, it merely does video frame decoding, and
	makes no attempt to keep track of the clock (as it should) nor to do any
	kind of audio output (yet).

	The video is also busted, I do not know why, but the "decoded"
	video is incorrect, it has the wrong colors.

	The video thread currently sends "messages" to the main thread
	to do two things: 

		* To inform the main thread that the video has been
		  initialized and that the video bounds can be computed.

		* To request an invalidate (when a new frame is ready)

	The invalidate request could *perhaps* be done by taking the
	Gdk lock and issuing the invalidate directly.

	The issue is that we might need to lock also on the
	(Item *) structures in case the user-code is making changes to the
	affine transform and hence the bounding box as we are trying
	to access those from the Gdk lock. 

* Rendering

	Currently we are creating a bitmap surface and we always copy
	it to the screen.  This approach is fine for non-compositing
	managers as this serves as our double-buffering primitive.

	David Reveman has some suggestions for the future:

		* We could create an xlib surface for the backing
		  store of the videos, this would help if we need
		  later to do video rendering in a separate process
		  or thread (for the compiz integration).

		* With a compositing manager we could use the xlib	
		  surface as this would properly synchornize and 
	 	  not require the client side double buffering. 

* Expose

	Currently repaints happen with an item_invalidate, I need to
	research if this clears the background before repainting.

* Usage of C++

	I do not know how to initialize instance fields in a structure
	with the contructor, so there is code like this:

	    struct {
		Agg2D *graphics;
	    }

	Then:

		something->graphics = new Agg2D ()

	Followed by uses of graphics in that way, there is probably a
	better way.

* Demo

	The demo has a couple of hardcoded videos for now, you must
	edit the filenames hardcoded inside of it.

	Sometimes you might also have to define VIDEO_DEMO at the top,
	as every once in a while I will disable them.

	There is currently a race condition in the rendering engine,
	I have not yet been able to find out what it is, so sometimes
	the engine will not display anything, restart it in those cases.

	You will notice some rectangles painting, thats where the
	video should be, it is also not clear why those move

* Debugging

	It is recommended that for now you do not `make install' as there
	is not much to use.

	To debug, use:

		cd src

		make debug

* Mozilla plugin

	It is recommended that for now you do not `make install' as there
	is not much to use.

	To browser plugin installation, use:

		make

		make install-plugin

	It will install all need stuff to your local plugin folder at
	~/.mozilla/plugins. In plugin/test folder theres a file 
	index.html that can be use to see plugin in action. Since plugin
	is under development, if you have any problems with it try to 
	execute your browser from command line and check log messsages, 
	this information can be useful to help us fix the problem.

----------------------------------------------------------------------------------
Issues
----------------------------------------------------------------------------------

* Reference Counting

	Should every DependencyObject that is "SetValue" be automatically
	base_ref?   

	I think it should, discuss with Chris, Jackson and Sebastien.

* Value and Kinds

	I wonder if we should move instead to use as keys not the enum
	values that we have, but instead the void * to the managed "Type"
	as the key for the various types.

	That would further unify the managed and native code

* XAML Parsing

	We are going to need a way of flagging classes as abstract to
	avoid instantiating those from XAML.

	Maybe a flag in UIElement::flags

* Cairo Considerations

	surface_clear: should we use something like this?

        cairo_set_source_rgba (s->cairo, 1.0, 1.0, 1.0, 1.0);
        cairo_set_operator (s->cairo, CAIRO_OPERATOR_SOURCE);
        cairo_paint (s->cairo);

	But with a rectangle to set the region to clear?

* Rendering Considerations

	Currently we draw in an off-screen cairo surface when the
	widget is not realized, seems like a waste of power, but its	
	used for bounding box computations.

	Should we have a if (!realized) return in those places and
	merely have a single cairo context that we paint to?


* Optimization Ideas

	The GSList that we use to keep track of attached objects could
	actually be abused to store the values there, we can use the
	bottom bit to track this info:

		If bottom bit is set, the pointer to the value stored
		there is:

			->value & ~1

		If the bit is not set, we got a regular pointer to a
		GSList.

